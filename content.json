{"meta":{"title":"Merlin's Blog","subtitle":null,"description":"一个热爱 AI 的技术博客","author":"merlin","url":"http://merlin153.com","root":"/"},"pages":[],"posts":[{"title":"C/C++指针问题","slug":"C++指针问题","date":"2019-07-18T09:34:19.000Z","updated":"2019-07-24T14:12:45.764Z","comments":true,"path":"2019/07/18/C++指针问题/","link":"","permalink":"http://merlin153.com/2019/07/18/C++指针问题/","excerpt":"","text":"记忆方法指针分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int a = 10;int b = 100;int* q;//若传入的是一级指针，则在修改传入指针值的时候是修改的传入指针的拷贝指向，//执行完毕后，拷贝部分会被释放，造成真正传入的指针没有被修改//传入一级指针函数void func_firstPoint(int* p) &#123; cout &lt;&lt; \"func_firstPoint:&amp;p=\" &lt;&lt; &amp;p &lt;&lt; \" ,p=\" &lt;&lt; p &lt;&lt; endl; p = &amp;b; //*p就是修改一级指针指向的地址，这里传入的q本身指向a的地址，改为指向b的地址 cout &lt;&lt; \"func_firstPoint:&amp;p=\" &lt;&lt; &amp;p &lt;&lt; \" ,p=\" &lt;&lt; p &lt;&lt; endl;&#125;//若传入二级指针函数void func_secondPoint(int** p)&#123; cout &lt;&lt; \"func_secondPoint:&amp;p=\" &lt;&lt; &amp;p &lt;&lt; \" ,p= \" &lt;&lt; p &lt;&lt;\" ,*p= \"&lt;&lt;*p&lt;&lt; endl; *p = &amp;b; //p本身是二级指针，所以*p一级指针的内容，这里传入的q本身指向a的地址，执行此句后改为指向b的地址。 cout &lt;&lt; \"func_secondPoint:&amp;p=\" &lt;&lt; &amp;p &lt;&lt; \" ,p=\" &lt;&lt; p &lt;&lt; \" , *p= \"&lt;&lt; *p&lt;&lt; endl;&#125;int main() &#123; //测试一级指针 cout &lt;&lt; \"*********以下是一级指针的测试***********\" &lt;&lt; endl; cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; \" ,&amp;b = \" &lt;&lt; &amp;b &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q&lt;&lt;\" ,q =\"&lt;&lt;q&lt;&lt;endl; q = &amp;a; cout &lt;&lt; \"*q = \" &lt;&lt; *q &lt;&lt; \" ,q = \" &lt;&lt; q &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q &lt;&lt; endl; func_firstPoint(q); cout &lt;&lt; \"*q = \" &lt;&lt; *q &lt;&lt; \" ,q =\" &lt;&lt; q &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q &lt;&lt; endl&lt;&lt;endl&lt;&lt;endl; cout &lt;&lt; \"*********以下是二级指针的测试**********\" &lt;&lt; endl; //测试二级指针 int *q=0; //重置q cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; \" ,&amp;b = \" &lt;&lt; &amp;b &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q &lt;&lt; \",q = \" &lt;&lt; q &lt;&lt; endl; q = &amp;a; cout &lt;&lt; \"*q = \" &lt;&lt; *q &lt;&lt; \" ,q = \" &lt;&lt; q &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q &lt;&lt; endl; func_secondPoint(&amp;q); cout &lt;&lt; \"*q = \" &lt;&lt; *q &lt;&lt; \" ,q = \" &lt;&lt; q &lt;&lt; \" ,&amp;q = \" &lt;&lt; &amp;q &lt;&lt; endl; //测试其他 cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; \"$$$$$$$$$$$$$$$$$$\" &lt;&lt; endl; int* m = 0; cout &lt;&lt; m &lt;&lt; endl; //m = &amp;a; //cout &lt;&lt; m &lt;&lt; endl; return 0;&#125; 代码分析（以下内容皆将基本变量的真实值说成真值）： 如下图，这是测试数据的初始化，请注意指针的初始化问题、访问方式（*p即是访问a的真值）： 下图是传入一级指针时在函数中发生的过程： 下图是传入二级指针时发生的过程，只有通过*p访问才会改变原来指向的值：","categories":[],"tags":[]},{"title":"c++问题答疑-01","slug":"c++问题答疑-01","date":"2019-07-07T13:43:14.000Z","updated":"2019-07-27T13:07:18.733Z","comments":true,"path":"2019/07/07/c++问题答疑-01/","link":"","permalink":"http://merlin153.com/2019/07/07/c++问题答疑-01/","excerpt":"","text":"一、基础问题1. 静态元素为什么需要初始化？如果不对其进行初始化，它将包含无法预测的值，因为内存保留最后一次操作时的内容。通过初始化数组，可确保内存包含确定的值。 2. 需要初始化动态数组的元素吗？实际上是不需要的。动态数组无需将其元素初始化为默认值，除非应用程序要求数组包含特定的初始值。 3. C++中计算将字符串长度时，包括末尾的空字符吗？不包括。例如“Hello World”的长度为11，这包括其中的空格，但不包括末尾的空字符。 4. ++i和i++的性能如何？前缀运算符(++i)性能在理论上是优于后缀运算符(i++)的，因为使用后缀运算符时，编译器需要临时存储初始值，一方需要将其赋给其他变量。 5. 如何退出无线循环？使用break退出当前循环；使用return退出当前函数模块。 6.编写一个类似于while(integer)的循环，如果Integer的值为-1，这个while循环会执行吗？理想情况下，while循环表达式应为布尔值 true 或 false，否则这样解读：零表示false，非 零表示true。由于-1是非零，因此该while条件为true，循环将执行。如果希望仅当Integer为正数时才执行循环，可编写表达式while(Integer&gt;0)。这种规则适用于所有的条件语句和循环。 7.如果递归函数不终止，结果将如何？递归函数会调用越来越多的栈空间，而栈空间是有限的，终将耗尽，最终应用程序会因为栈溢出而崩溃。 8.既然能将函数申明为内联以提高执行速度，为何不将所有函数生命为内联的？看情况而定，如果在很多地方使用内联函数，这将导致代码急剧膨胀。另外，根据性能设置，大多数较新的编译器能判断是否应用内联函数。 9.","categories":[{"name":"C++","slug":"C","permalink":"http://merlin153.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://merlin153.com/tags/C/"}],"author":"merlin"},{"title":"python爬虫基础01","slug":"python爬虫基础01","date":"2019-06-22T09:16:47.000Z","updated":"2019-06-22T06:13:55.975Z","comments":true,"path":"2019/06/22/python爬虫基础01/","link":"","permalink":"http://merlin153.com/2019/06/22/python爬虫基础01/","excerpt":"","text":"一、简介1、urllib库和URLError异常处理urllib库是python中的一个功能强大、用于操作URL，并在做爬虫时经常用到的库。在python2.x中分urllib库和urllib2库，python3.x则直接合并为了urllib库，且使用方法稍有不同，本文（或者说整个体系皆以python3.x）做记录。 2、urllib快速爬取网页(1). 导入urllib库 1&gt;&gt;&gt; import urllib.request (2). 爬取一个网页 例如爬取百度的首页，用urllib.request.urlopen打开需要爬取的网页： 1&gt;&gt;&gt; file = urllib.request.urlopen(&quot;http://www.baidu.com&quot;) 将获取的结果放置在了 file 变量中，下面使用 file.read() 读取全部内容，也可以使用 readline 读取一行内容： 12&gt;&gt;&gt; data = file.read()&gt;&gt;&gt; dataline = file.readline() 可以看到用两种方式分别爬取到了全部内容和一行内容，可以查看(print或者直接输出都可以)变量内容和变量类型： 1234567891011&gt;&gt;&gt; datab'&lt;!DOCTYPE html&gt;\\n&lt;!--STATUS OK--&gt;\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\t\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\t\\r\\n \\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\t\\t \\r\\n\\r\\n\\t\\r\\n \\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\r\\n\\t\\t\\t \\r\\n\\t\\t\\t \\r\\n\\r\\n\\r\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&lt;html&gt;\\n&lt;head&gt;\\n \\n &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;\\n &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;\\n\\t&lt;meta content=\"always\" name=\"referrer\"&gt;\\n (此处省略很多)&gt;&gt;&gt; type(data)&lt;class 'bytes'&gt;&gt;&gt;&gt; datalineb''&gt;&gt;&gt; type(dataline)&lt;class 'bytes'&gt; 读取内容常见的有3中方式，用法为： file.read() 读取文件的全部内容，与 readlines 不同的是，read 会把读取到的内容赋给一个字符串变量。 file.readlines() 读取文件的全部内容，但是 readlines() 会将读取到的内容赋给一个列表变量 ，若读取网页全部内容，推荐 readlines() 。 file.readline() 读取文件的一行。 (3). 将爬取的内容持久化(存入磁盘文件中) 1234&gt;&gt;&gt; file_handle = open(\"/home/whispersilence/python/reptile_test/1.html\",\"wb\")&gt;&gt;&gt; file_handle.write(data)153754&gt;&gt;&gt; file_handle.close() 首先通过 open() 函数打开了该文件，以”wb”（二进制写入）方式打开，打开后将句柄赋给变量 file_handle ，然后用 write() 写入对应的数据 data ，此时输出的结果是写入的字节数 153754 ，写入完毕后通过 close() 方法关闭文件，保证安全性。 用浏览器打开 1.html 文件后发现除了图片其他界面都很正常。 (4). 第二种方法：urlretrieve() 函数 使用 urllib.request 里面的urlretrieve() 函数直接将信息写入本地文件，格式为：urllib.request.urlretrieve(url,filename = “本地文件地址”)，例如: 1&gt;&gt;&gt; filename = urllib.request.urlretrieve(\"http://www.merlin153.com\",filename=\"/home/whispersilence/python/reptile_test/2.html\") 执行完成后，可以发现目录中多了 2.html 文件，该文件内容就是请求地址的网页源码。 注意：urlretrieve 执行的过程中会产生一些缓存，若想清除这些信息，执行 urlcleanup() : 12&gt; &gt;&gt;&gt; urllib.request.urlcleanup()&gt; 3、浏览器的模拟(1). 使用 build_opener() 修改报头 12345&gt;&gt;&gt; url = \"https://juejin.im/timeline\"&gt;&gt;&gt; headers = (\"User-Agent\",\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Mobile Safari/537.36\")&gt;&gt;&gt; opener = urllib.request.build_opener()&gt;&gt;&gt; opener.addheaders = [headers]&gt;&gt;&gt; data = opener.open(url).read() 选择确定一个 url 再定义一个变量 headers 存储对应的 User-Agent 信息，定义的格式为（”User-Agent”,”具体信息”） 使用 urllib.request.build_opener() 创建自定义的 opener 对象，通过 opener.addheaders 设置头信息。 然后写入文件中 1234&gt;&gt;&gt; filehandle = open(\"/home/whispersilence/python/reptile_test/3.html\",\"wb\")&gt;&gt;&gt; filehandle.write(data)97736&gt;&gt;&gt; filehandle.close() (2). 使用add_header() 设置要爬取的 url 网址 使用urllib.request.Request(url) 创建 Request 对象并赋给变量 req , 然后使用 add_header() 方法添加报头信息，格式为：Request对象名.add_header(字段名，字段值)。 例： 123456789&gt;&gt;&gt; url = \"\"&gt;&gt;&gt; req = urllib.request.Request(url)&gt;&gt;&gt; req.add_header(\"User-Agent\",\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Mobile Safari/537.36\")&gt;&gt;&gt; data = urllib.request.urlopen(req).read()&gt;&gt;&gt; filehandle = open(\"/home/whispersilence/python/reptile_test/4.html\",\"wb\")&gt;&gt;&gt; filehandle.write(data)97736&gt;&gt;&gt; filehandle.close() 4、超时设置超时一般用于用户访问网页的响应情况，若长时间不能收到服务器的响应，就做下一步动作，也是保证爬虫能够继续执行程序的必然要求。但是很多时候，服务器一般都能在 1s 内做出响应，使用户感受不到有什么异常发生。下面模拟一下超时响应： 12345678import urllib.requestfor i in range(1,100): try: file = urllib.request.urlopen(\"http://yum.iqianyue.com\",timeout=30) data = file.read() print(len(data)) except Exception as e: print(\"异常--&gt;\"+str(e))","categories":[{"name":"爬虫实践","slug":"爬虫实践","permalink":"http://merlin153.com/categories/爬虫实践/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://merlin153.com/tags/爬虫/"}],"author":"merlin"},{"title":"python-11-zip()和enumerate()","slug":"进阶python-11-zip-和enumerate","date":"2019-06-11T20:24:42.000Z","updated":"2019-06-22T11:51:52.808Z","comments":true,"path":"2019/06/12/进阶python-11-zip-和enumerate/","link":"","permalink":"http://merlin153.com/2019/06/12/进阶python-11-zip-和enumerate/","excerpt":"","text":"zip()源头假如让你计算 a = [1,2,3,4] ,b = [11,22,33,44] 两个列表的对应元素的和，你会怎么处理呢？12345678&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = [11,22,33,44]&gt;&gt;&gt; c = []&gt;&gt;&gt; for i in range(len(a)):... c.append(a[i]+b[i])&gt;&gt;&gt; c[12,24,36,48] zip()解决方案是的，在不知道的前提下，你肯定会这么做。但是 python 提供一个内建函数 zip(), zip()是一个内置函数，他的参数必须是某种序列数据类型，如果是字典，则将其视为序列。然后将序列对应的元素依次组成元组，并单做列表中的元素。1234&gt;&gt;&gt; s=&#123;\"name\":\"sunwukong\"&#125;&gt;&gt;&gt; t=&#123;\"action\":\"qujingshu\"&#125;&gt;&gt;&gt; zip(s,t)[(\"name\",\"action\")] 下面这个是比较特殊的情况1234567&gt;&gt;&gt;a = \"hello\"&gt;&gt;&gt;zip(a)[('h',), ('e',), ('l',), ('l',), ('o',)]&gt;&gt;&gt; c = [1,2,3,4]&gt;&gt;&gt; zip(c)[(1,), (2,), (3,), (4,)] 注意：因为只提供了一个参数，此时元组就是一个元素，此时元组中元素后面都要有一个逗号。 所以源头的问题可以用以下方式解决：123456&gt;&gt;&gt; d = []&gt;&gt;&gt; for x,y in zip(a,b):... d.append(x+y)&gt;&gt;&gt;d[12, 24, 36, 48] 再看另一种情况，长度不一致时：123456&gt;&gt;&gt; a = \"hello\"&gt;&gt;&gt; n = [1,2,3,4]&gt;&gt;&gt; zip(a,n)[('h', 1), ('e', 2), ('l', 3), ('l', 4)]&gt;&gt;&gt; zip(n,a)[(1, 'h'), (2, 'e'), (3, 'l'), (4, 'l')] 可以发现是以长度较短的序列为基准的，超出了长度就不会使用这样的相加的方法的。 下面再看另一种写法：1234567891011121314&gt;&gt;&gt; a = \"hello\"&gt;&gt;&gt; n = [1,2,3,4]&gt;&gt;&gt; c = []&gt;&gt;&gt; for i in range(len(n)):... c.append(str(n[i])+\":\"+a[i])&gt;&gt;&gt; c['1:h', '2:e', '3:l', '4:l', '1:h', '2:e', '3:l', '4:l']&gt;&gt;&gt; d = []&gt;&gt;&gt; for x,y in zip(a,n):... d.append(x+\":\"+str(y))&gt;&gt;&gt; d['h:1', 'e:2', 'l:3', 'l:4'] 还有个比较好玩的变换方法：12345678&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = [11,22,33,44]&gt;&gt;&gt; ab = zip(a,b)&gt;&gt;&gt; ab[(1, 11), (2, 22), (3, 33), (4, 44)]&gt;&gt;&gt; zip(*ab)[(1, 2, 3, 4), (11, 22, 33, 44)] enumerate()问题如何将列表元素的索引和元素值获取到呢？传统解决方案： 1234567891011week = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']for i in range(len(week)): print(week[i]+\" is \"+ str[i])# 结果monday is 0tuesday is 1wednesday is 2thursday is 3friday is 4 注意：这里的 i 是 int 类型，如果和前面的 “+” 连接，所以必须是 str 类型 enumerate()解决方案123456789for (i,day) in enumerate(week): print(day + \" is \"+ str(i)) # 结果monday is 0tuesday is 1wednesday is 2thursday is 3friday is 4 其他使用方式（参考）123456&gt;&gt;&gt; week = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']&gt;&gt;&gt; list(enumerate(week))[(0, 'monday'), (1, 'tuesday'), (2, 'wednesday'), (3, 'thursday'), (4, 'friday')]&gt;&gt;&gt; list(enumerate(week,start = 1))[(1, 'monday'), (2, 'tuesday'), (3, 'wednesday'), (4, 'thursday'), (5, 'friday')] 练习描述将下面的某些字符串替换为其他字符串。 str1 = “I love Python,but I also love C ,Python is very concise!” , 将 Python 替换成 Chinese。 12345678910&gt;&gt;&gt; str1 = \"I love Python but I also love C Python is very concise!\"&gt;&gt;&gt; s_str1 = str1.split(\" \")&gt;&gt;&gt; s_str1['I', 'love', 'Python', 'but', 'I', 'also', 'love', 'C', 'Python', 'is', 'very', 'concise!']&gt;&gt;&gt; for i,str in enumerate(s_str1):... if str == \"Python\":... s_str1[i] = \"Chinese\"# 结果['I', 'love', 'Chinese', 'but', 'I', 'also', 'love', 'C', 'Chinese', 'is', 'very', 'concise!'] 想想怎么将已经 split() 过的变量再次 split()（循环内做分割），例如 str1 = “I love Python，but I also love C ，Python is very concise!” 方案1：使用 re 模块的多字符分割(符合上面的结果却不符合过程) 1234&gt;&gt;&gt; import re&gt;&gt;&gt; str1=\"I love Python,but I also love C ,Python is very concise!\"&gt;&gt;&gt; re.split(\" |,\",str1) ['I', 'love', 'Python', 'but', 'I', 'also', 'love', 'C', '', 'Python', 'is', 'very', 'concise!'] 注意上述语法是以空格和 , （英文状态的 ,）做的分割，所以可以看到列表结果里面没有 , 和空格。 方案2：摸索中… 还有很多细节没有注意到，持续更新中…","categories":[{"name":"Python进阶","slug":"Python进阶","permalink":"http://merlin153.com/categories/Python进阶/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"进阶python-10(遍历)","slug":"进阶python-10-遍历","date":"2019-06-10T14:52:15.000Z","updated":"2019-06-11T12:21:55.028Z","comments":true,"path":"2019/06/10/进阶python-10-遍历/","link":"","permalink":"http://merlin153.com/2019/06/10/进阶python-10-遍历/","excerpt":"","text":"for 的对象重点：所有的序列类型对象都能够用 for 来遍历 1.字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# for遍历字符串&gt;&gt;&gt; str1 = &quot;I&apos;m String&quot;;&gt;&gt;&gt; for i in x.items():... print(i)...I&apos;mString# list()遍历&gt;&gt;&gt; s1 = list(str1)&gt;&gt;&gt; s1[&apos;I&apos;, &quot;&apos;&quot;, &apos;m&apos;, &apos; &apos;, &apos;S&apos;, &apos;t&apos;, &apos;r&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;]&gt;&gt;&gt; for i in s1:&gt;&gt;&gt; print(i) #考虑下怎么不换行输出I&apos;mString# set()集合遍历&gt;&gt;&gt; str1_set = set(str1)&gt;&gt;&gt; str1_set&#123;&quot;&apos;&quot;, &apos;n&apos;, &apos;i&apos;, &apos;r&apos;, &apos;g&apos;, &apos;m&apos;, &apos;S&apos;, &apos;I&apos;, &apos; &apos;, &apos;t&apos;&#125;&gt;&gt;&gt; for i in str1_set:... print(i)&apos;nirgmSIt# 元组 tuple 遍历&gt;&gt;&gt; str1_tuple = tuple(str1)&gt;&gt;&gt; str1_tuple(&apos;I&apos;, &quot;&apos;&quot;, &apos;m&apos;, &apos; &apos;, &apos;S&apos;, &apos;t&apos;, &apos;r&apos;, &apos;i&apos;, &apos;n&apos;, &apos;g&apos;)&gt;&gt;&gt;for i in str1_tuple:... print(i)I&apos;mString# 字典 dict 遍历&gt;&gt;&gt; dict1 = &#123;&quot;name&quot;:&quot;sunwukong&quot;,&quot;action&quot;:&quot;qujingshu&quot;&#125;&gt;&gt;&gt; for i in dict1.items():... print(i)(&apos;name&apos;, &apos;sunwukong&apos;)(&apos;action&apos;, &apos;qujingshu&apos;) 对于这里的字典，获得字典键、值的函数有：items/iteritems/keys/iterkeys/values/itervalues,但是通常来说推荐使用含有 iter 的方法，因为效率会比较高。","categories":[{"name":"Python进阶","slug":"Python进阶","permalink":"http://merlin153.com/categories/Python进阶/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"进阶Python-09(拷贝)","slug":"进阶python-09-拷贝","date":"2019-06-10T12:36:01.000Z","updated":"2019-06-10T05:53:20.581Z","comments":true,"path":"2019/06/10/进阶python-09-拷贝/","link":"","permalink":"http://merlin153.com/2019/06/10/进阶python-09-拷贝/","excerpt":"","text":"字典中的拷贝拷贝是 copy 的音译，即为“复制”的意思。一般的理解中，是直接将原来的东西复制一份，但是在 Python 中是如何进行操作的呢？先看看如下的代码： 12345678&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt;id(a)504353840&gt;&gt;&gt;id(b)504353840 可以看出这样的复制是“表面形式”的，相当于 Python 把这个常量的标签贴给了两个变量，本质上系统中只有一个常量（该常量的地址是唯一的）。 再来看看 dict 类型：1234567&gt;&gt;&gt; ad = &#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:18&#125;&gt;&gt;&gt; bd = ad&gt;&gt;&gt; id(ad)70304272&gt;&gt;&gt; id(bd)70304272 调用copy之后： 12345&gt;&gt;&gt; cd = ad.copy()&gt;&gt;&gt; cd&#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;age&apos;: 18&#125;&gt;&gt;&gt; id(cd)75451344 可以发现调用 copy() 方法之后，查看了变量的 id 后，说明 python 为 cd 新开辟了空间。所以可以当做变量就是对象的标签。 但是，如果字典中含有列表呢？数据的拷贝还会是一样的方式吗？ copy() 方法还能起作用吗？看代码：12345678&gt;&gt;&gt; x = &#123;&quot;name&quot;:&quot;genie&quot;,&quot;lang&quot;:[&quot;sunwukong&quot;,&quot;72bian&quot;,&quot;qujingshu&quot;]&#125;&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;72bian&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; id(x)75448512&gt;&gt;&gt; id(y)75436896 可以看出 x , y 是两个不同的对象，因为他们的 id 值不一样。但是，别这么早下结论哦，执行下面的语句：123456&gt;&gt;&gt; y[&quot;lang&quot;].remove(&quot;72bian&quot;)&gt;&gt;&gt; y&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; x&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125; 注意到了吗？结果都是一样的，操作了应用 copy() 方法的拷贝对象，但是却得到了两个对象值一样的结果，这说明什么呢？在来看看一样的操作：12345&gt;&gt;&gt; y[&quot;name&quot;] = &quot;name1&quot;&gt;&gt;&gt; y&#123;&apos;name&apos;: &apos;name1&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; x&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125; 看出了猫腻吧？解释：观察 x 参数是有两个键值对组成的字典，一个是普通的键值对，另一个是包含了列表的键值对。注意列表不属于基本类型，而字符串是基本数据类型，所以修改列表时，另一个也会随着更改，修改字符串时，另一个就不会跟着修改。 深层次原因：python只能存储基本类型，例如int,str等，对于不是基本类型的，比如此案例的字典值是列表，python不会在被复制的那个对象中重新存储，而是使用引用的方式，指向原来的值。说的直白点，python面对基本类型时，在内存中新建窝点，面对非基本类型的，就用引用指向原来的窝点。（所以copy()也叫“浅拷贝”） 与“浅拷贝”对应的是“深拷贝”，不过在使用时需要导入模块：import copy123456789101112131415&gt;&gt;&gt;x&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt;y&#123;&apos;name&apos;: &apos;name1&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; id(x)75448512&gt;&gt;&gt; id(y)75436896#让 z 深拷贝一份 x&gt;&gt;&gt; z = copy.deepcopy(x)&gt;&gt;&gt; z&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; id(z)75449664 可以看出 z 新起了一个 窝点，按照理解中的，修改 z 中的值是不会影响 x 中的值的。12345678910111213#向 x 中添加元素&gt;&gt;&gt; x[&quot;age&quot;] = 18&gt;&gt;&gt; x&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;], &apos;age&apos;: 18&#125;&gt;&gt;&gt; z&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;]&#125;&gt;&gt;&gt; z[&quot;lang&quot;].append(&quot;一路斩妖除魔&quot;)&gt;&gt;&gt; z&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;qujingshu&apos;, &apos;一路斩妖除魔&apos;]&#125;&gt;&gt;&gt; z[&quot;lang&quot;].remove(&quot;qujingshu&quot;)&gt;&gt;&gt; z&#123;&apos;name&apos;: &apos;genie&apos;, &apos;lang&apos;: [&apos;sunwukong&apos;, &apos;一路斩妖除魔&apos;]&#125;","categories":[{"name":"Python进阶","slug":"Python进阶","permalink":"http://merlin153.com/categories/Python进阶/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"Python--debug心得","slug":"Python-debug心得","date":"2019-05-12T20:30:02.000Z","updated":"2019-06-23T12:16:53.070Z","comments":true,"path":"2019/05/13/Python-debug心得/","link":"","permalink":"http://merlin153.com/2019/05/13/Python-debug心得/","excerpt":"","text":"debug操作今天突然萌生个有意思的想法，但是经过测试后，知道了结果但是却不知原理，所以就想 debug 测试下，看看内存情况，这个想法具体是这样的（用迭代遍历的方法改变列表中某个值），代码如下：1234567a = [1,2,3,4,5,6]for i in a: if i == 5: i = 10 print(i) print(i)print(a) debug操作过程如下（F7执行下一步，alt+shift+f7进入方法体内部）： 分析：这种形式的遍历有点像是给列表 a 分配了一个临时变量，执行完 for 遍历后会释放这个临时变量，所以令 i = 10 的做法在释放后，也就变成了原来的 5 。 再看另一种写法： 12345for i in range(len(a)): if a[4] == 5: a[4] = 10 print(a[i])print(a) 同如上个测试的一样的debug操作： 可以发现这样的操作就类似 C 或 Java 语言的操作，在执行 for 循环的过程中，操作的就是实际的值，而不是临时变量，这样就在遍历的过程中改变了列表中的值。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"计算机小数","slug":"计算机小数","date":"2019-05-08T14:06:15.000Z","updated":"2019-05-08T06:10:10.319Z","comments":true,"path":"2019/05/08/计算机小数/","link":"","permalink":"http://merlin153.com/2019/05/08/计算机小数/","excerpt":"","text":"概述问题来源 简单说下为什么计算机只认得 0,1 值的，其实严格来说也不叫认识，只是人为的一种规定。但为什么就不能用我们熟悉的十进制呢？在最最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，人们为了方便计算规定一个为 0 一个为 1 ，使用二进制容易基于这些电子器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。 在刚开始接触计算机时就产生了这样的疑问： 既然计算机是二进制的，由一堆仅为 0,1 这样的数字堆叠而成，那它又是怎么样表示小数的呢？ 为什么在 C 语言, C++ 等这样的语言里表示例如 float 这样的小数的时候，却要在赋值的后面加上 f 这个的标志呢？例如：float f = 0.1f;这个问题越来越多的出现在后面的开发中，各种语言对小数的处理办法也有所区别，但是为什么这样一个看起来不起眼的小数为何要花大工夫处理呢？下面就从底层原理归纳下。 实际中的问题用 Java 测试如下代码：1234float f1 = 0.2f+0.2f;float f2 = 0.2f*0.2f;System.out.println(f1);System.out.println(f2); 这个程序按理应该输出 0.4 和 0.04 ，实际上输出的却是0.4 和 0.040000003，难道是计算机算错了？ 简单答案实际上运算本身不会出错，而是计算机本身不能精确表示很多数，比如 0.2 这个数，它只能表示一个非常接近但又不等于 0.2 的一个数(下面有分析)，所以本身表示的值都不精确，运算的结果不精确也就不足为奇了。那么问题又来了，计算机为什么表示不清楚这样的小数，它能表示清楚哪些小数呢？ 计算机为什么不能精确表示小数这个问题严格来说问的也不准确，计算机并不能完全精确表示所有小数，但有些小数是可以精确表示的，比如0.25可以精确表示，但是 0.2 却是一个逼近值表示的。 0.2 怎么会不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。 一. 十进制表示 实际上，十进制也只能表示那些可以表述为10的多少次方和的数，比如12.345，实际上表示的：110+21+30.1+40.01+5*0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为 0.1,0.01,0.001,…即10^(-1), 10^(-2), 10^(-3)。 但是很多数，十进制也是不能精确表示的，比如1/3, 保留三位小数的话，十进制表示是0.333，但无论后面保留多少位小数，都是不精确的，用0.333进行运算，比如乘以3，期望结果是1，但实际上却是0.999。 二. 二进制表示 二进制就是使用 0,1 表示的数字，例如 101.11 就等于 1 2^2 +0 2^1 + 12^0 + 12^-1 + 1*2^-2 = 4+0+1+1/2+1/4 = 5.75 ，下图展示了二进制小数的表达方式: 右图可知，对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）现在问题来了， 计算机只能用这些个 1/(2^n） 之和来表达十进制的小数。我们来试一试如何表达十进制的 0.2 吧。 0.01 = 1/4 = 0.25 ,太大 0.001 =1/8 = 0.125 , 又太小 0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了 0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了 0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大 0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错 继续逼近:0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875已经很逼近了， 就这样吧！所以可以看出，0.2这样的小数是没有办法表示清楚的。 但是比如0.25、0.125 等这样的小数就可以表示清楚，因为这种值是不需要用逼近的方法的。 怎么处理不精确问题大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白缘由了，再来分析上面那个程序的因果。原来上述的结果只是 Java 语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。在误差足够小的时候，结果看上去是精确的，但不精确其实才是常态。 如果真的需要比较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数，另外的方法一般是使用十进制的数据类型，这个没有统一的规范，在Java中是BigDecimal，运算更准确，但效率比较低，本节就不详细说了。 另一个问题浮点数为什么叫浮点数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候我们用”小数”这个词表示 float 和 double 类型，其实，这是不严谨的，”小数”是在数学中用的词，而在计算机中，我们一般说的是”浮点数”。float和double被称为浮点数据类型，小数运算被称为浮点运算。为什么要叫浮点数呢？这是由于小数的二进制表示中，表示某个小数的小数点的时候，点不是固定的，而是浮动的。 例如： 我们还是用10进制类比，10进制有科学表示法，比如123.45这个数，直接这么写，就是固定表示法，如果用科学表示法，在小数点前只保留一位数字，可以写为1.2345E2即1.2345*(10^2)，即在科学表示法中，小数点向左浮动了两位。 二进制中为表示小数，也采用类似的科学表示法，形如 m*(2^e)。m称为尾数，e称为指数。指数可以为真，也可以为负，负的指数表示哪些接近0的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负。 浮点数在计算机中的表示标准几乎所有的硬件和编程语言表示小数的二进制格式都是一样的，这种格式是一个标准，叫做IEEE 754标准，它定义了两种格式，一种是32位的，对应于Java的float，另一种是64位的，对应于Java的double。在两种格式中，除了表示正常的数，标准还规定了一些特殊的二进制形式表示一些特殊的值，比如负无穷，正无穷，0，NaN (非数值，比如0乘以无穷大)。 32位格式中，1位表示符号，23位表示尾数，8位表示指数。64位格式中，1位表示符号，52位表示尾数，11位表示指数。 总结由于浮点数表示的这种“不精确性”或者说是“近似性”， 对于精确度要求不高的运算还行， 如果我们用float或者double 来做哪些要求精确的运算（例如银行）时就要小心了, 很可能得不到你想要的结果。具体的改进方法推荐大家看看《Effective Java》在第48条所推荐的“使用BigDecimal来做精确运算”。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merlin153.com/categories/计算机基础/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://merlin153.com/tags/计算机/"}],"author":"merlin"},{"title":"Python爬虫实践01","slug":"Python爬虫实践01","date":"2019-05-08T13:50:28.000Z","updated":"2019-05-08T06:00:54.184Z","comments":true,"path":"2019/05/08/Python爬虫实践01/","link":"","permalink":"http://merlin153.com/2019/05/08/Python爬虫实践01/","excerpt":"","text":"猫眼项目实践此项目目的是提取猫眼电影TOP榜单中的电影信息存储于CSV文件中，也是我的第一个网页爬虫实践。 静态网页实践 通过观察，可以发现猫眼的排榜页存在一些规律，每页都有个偏移量，URL的变化规律是参数offset值不断偏移，每页偏移的值为10，由此我们可以编写一个获取每页数据函数，接收参数就是页码数，如下： 1234第二页： http://maoyan.com/board/4?offset=10第三页： http://maoyan.com/board/4?offset=20第四页： http://maoyan.com/board/4?offset=30...... 获取到html页面后，就可以提取相应的电影信息，比如榜单张每一项电影都会有的属性：电影名称，主演，上映时间，评分等信息。提取信息采用正则表达式提取电影信息，然后将这些信息写入CSV文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import requestsimport reimport csvimport timeheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'&#125;params = &#123; 'offset': 0&#125;def get_html(page): ''' 获取一页html页面 :param page: 页数 :return: 该页html页面 ''' params['offset'] = page * 10 url = 'http://maoyan.com/board/4' try: response = requests.get(url, headers=headers, params=params) if response.status_code == 200: html = response.text return html else: return -1 except: return Nonedef parse_infor(html): ''' 提取html页面中的电影信息 :param html: html页面 :return: 电影信息列表 ''' pat = re.compile('&lt;div class=\"movie-item-info\"&gt;.*?&lt;p.*?&gt;&lt;a.*?&gt;(.*?)&lt;/a&gt;&lt;/p&gt;.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;.*?&lt;/div&gt;.*?&lt;div.*?&gt;.*?&lt;p.*?&gt;&lt;i.*?&gt;(.*?)&lt;/i&gt;&lt;i.*?&gt;(.*?)&lt;/i&gt;&lt;/p&gt;.*?&lt;/div&gt;.*?&lt;/div&gt;.*?&lt;/div&gt;', re.S) results = re.findall(pat, html) one_page_film = [] if results: for result in results: film_dict = &#123;&#125; # 获取电影名信息 film_dict['name'] = result[0] # 获取主演信息 start = result[1] # 替换字符串中的 '\\n' 字符，即换行字符 start.replace('\\n', '') # 去掉字符串两边的空格，并使用切片去除字符串开头的'主演：'三个字符 start = start.strip()[3:] film_dict['start'] = start # 获取上映时间信息 releasetime = result[2] # 使用切片去除字符串开头的'上映时间：'五个字符 releasetime = releasetime[5:] film_dict['releasetime'] = releasetime # 获取评分信息 left_half =result[3] right_half = result[4] score = left_half + right_half film_dict['score'] = score # 打印该电影信息： print(film_dict) # 将该电影信息字典存入一页电影列表中 one_page_film.append(film_dict) return one_page_film else: return Nonedef save_infor(one_page_film): ''' 存储提取好的电影信息 :param one_page_film: 电影信息列表 :return: None ''' with open('top_film.csv', 'a', newline='', errors='ignore') as f: csv_file = csv.writer(f) for one in one_page_film: csv_file.writerow([one['name'], one['start'], one['releasetime'], one['score']])if __name__ == \"__main__\": # 利用循环构建页码 for page in range(10): # 请求页面 html = get_html(page) if html: # 提取信息 one_page_film = parse_infor(html) if one_page_film: # 存储信息 save_infor(one_page_film) time.sleep(1) 动态网实践打开猫眼专业版-实时票房然后我们可以看见现在的实时电影票房数据，可以看见 “今日实时” 的数据在不断地动态增加,这样随着时间推移而变化数据的网页就是动态网页。通过查看该网页源代码，发现并没有电影相关的票房等信息，那么可以判断该页面可能使用了Ajax(即“Asynchronous Javascript And XML”(异步 JavaScript 和 XML))技术，一种动态网页的技术。进一步分析，可以发现每隔一段时间都会有一个新的请求，其请求类型都为xhr，而Ajax的请求类型就是xhr，这请求可能就是实时更新的票房信息，而我们需要的数据可能就在这些文件里。 于是可以模拟该请求：123456789101112131415161718192021headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'&#125;def get_html(): ''' 获取JSON文件 :return: JSON格式的数据 ''' # 请求second.json的URL url = 'https://box.maoyan.com/promovie/api/box/second.json' try: response = requests.get(url, headers=headers) if response.status_code == 200: # 由于是JSON文件，我们可以返回JSON格式的数据便于后续提取 return response.json() else: return -1 except: return None 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'&#125;def get_html(): ''' 获取JSON文件 :return: JSON格式的数据 ''' # 请求second.json的URL url = 'https://box.maoyan.com/promovie/api/box/second.json' try: response = requests.get(url, headers=headers) if response.status_code == 200: # 由于是JSON文件，我们可以返回JSON格式的数据便于后续提取 return response.json() else: return -1 except: return Nonedef parse_infor(json): ''' 从JSON数据中提取电影票房数据，包括：电影名，上映信息，综合票房，票房占比，累计票房 :param json: JSON格式的数据 :return: 每次循环返回一次字典类型的电影数据 ''' if json: # 利用json中的get()方法层层获取对应的信息 items = json.get('data').get('list') for item in items: piaofang = &#123;&#125; piaofang['电影名'] = item.get('movieName') piaofang['上映信息'] = item.get('releaseInfo') piaofang['综合票房'] = item.get('boxInfo') piaofang['票房占比'] = item.get('boxRate') piaofang['累计票房'] = item.get('sumBoxInfo') # 利用生成器每次循环都返回一个数据 yield piaofang else: return Nonedef save_infor(results): ''' 存储格式化的电影票房数据HTML文件 :param results: 电影票房数据的生成器 :return: None ''' rows = '' for piaofang in results: # 利用Python中的format字符串填充html表格中的内容 row = '&lt;tr&gt;&lt;td&gt;&#123;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#125;&lt;/td&gt;&lt;/tr&gt;'.format(piaofang['电影名'], piaofang['上映信息'], piaofang['综合票房'], piaofang['票房占比'], piaofang['累计票房']) # 利用字符串拼接循环存储每个格式化的电影票房信息 rows = rows + '\\n' + row # 利用字符串拼接处格式化的HTML页面 piaofang_html = '''&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电影票房&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; .table1_5 table &#123; width:100%; margin:15px 0 &#125; .table1_5 th &#123; background-color:#00BFFF; color:#FFFFFF &#125; .table1_5,.table1_5 th,.table1_5 td &#123; font-size:0.95em; text-align:center; padding:4px; border:1px solid #dddddd; border-collapse:collapse &#125; .table1_5 tr:nth-child(odd)&#123; background-color:#aae9fe; &#125; .table1_5 tr:nth-child(even)&#123; background-color:#fdfdfd; &#125; &lt;/style&gt; &lt;table class='table1_5'&gt; &lt;tr&gt; &lt;th&gt;电影名&lt;/th&gt; &lt;th&gt;上映信息&lt;/th&gt; &lt;th&gt;综合票房&lt;/th&gt; &lt;th&gt;票房占比&lt;/th&gt; &lt;th&gt;累计票房&lt;/th&gt; &lt;/tr&gt; ''' + rows + ''' &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; ''' # 存储已经格式化的html页面 with open('piaofang.html', 'w', encoding='utf-8') as f: f.write(piaofang_html)if __name__ == \"__main__\": # 获取信息 json = get_html() # 提取信息 results = parse_infor(json) # 存储信息 save_infor(results) 结果如下：","categories":[{"name":"爬虫实践","slug":"爬虫实践","permalink":"http://merlin153.com/categories/爬虫实践/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://merlin153.com/tags/爬虫/"}],"author":"merlin"},{"title":"Python爬虫实践","slug":"Python爬虫实践","date":"2019-05-08T13:49:40.000Z","updated":"2019-05-08T06:03:09.944Z","comments":true,"path":"2019/05/08/Python爬虫实践/","link":"","permalink":"http://merlin153.com/2019/05/08/Python爬虫实践/","excerpt":"","text":"爬虫原理用户获取网络数据的方式有以下两种： 浏览器提交HTTP请求—&gt;下载网页代码—&gt;解析成页面。 模拟浏览器发送请求(获取网页代码)-&gt;提取有用的数据-&gt;存放于数据库或文件中。而爬虫做的事情，大致过程如下: 通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers等信息，等待服务器的响应 如果服务器正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能有HTML、JSON、二进制文件（如图片、视频等类型）。 得到的内容可能是HTML，可以用正则表达式、网页解析库进行解析。可能是JSON，可以直接转成JOSN对象进行解析，可能是二进制数据，可以保存或者进一步处理 保存形式多样，可以保存成文本，也可以保存至数据库，或者保存成特定格式的文件。 了解网页打开一个网页(推荐Chrome)，右键检查(或者F12)，在打开的界面中点开 network 选项，可以先清空，然后刷新界面，随便点开一个数据包，里面的具体释义如下： 第一列Name:请求的名称，一般会将URL的最后一 部分内容当作名称。 第二列Status: 响应的状态码，这里显示为200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 第三列Type: 请求的文档类型。这里为document, 代表我们这次请求的是一个HTML文档,内容就是一些HTML代码。 第四列initiator: 请求源。用来标记请求是由哪个对象或进程发起的。 第五列Size: 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示from cache。 第六列Time:发起请求到获取响应所用的总时间。 第七列Waterfall:网络请求的可视化瀑布流。 接下来我们分析请求的详细组成，比如点第一个请求即Name为www.baidu.com的请求，如下图所示： 我们看到响应中分General部分，请求头、响应头General一般包含以下部分： Request URL为请求的URL Request Method为请求的方法 Status Code为响应状态码， Remote Address为远程服务器的地址和端口Response Headers一般包含以下部分(响应(服务端-&gt;客户端[response]))： HTTP/1.1为响应采用的协议和版本号 200 (状态码) OK(描述信息) Location为服务端需要客户端访问的页面路径 Server为服务端的Web服务端名 Content-Encoding为服务端能够发送压缩编码类型Content-Length为服务端发送的压缩数据的长度 Content-Language为服务端发送的语言类型 Content-Type为服务端发送的类型及采用的编码方式 Last-Modified为服务端对该资源最后修改的时间 Refresh为服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径 Content-Disposition为服务端要求客户端以下载文件的方式打开该文件 Transfer-Encoding为分块传递数据到客户端 Set-Cookie为服务端发送到客户端的暂存数据 Connection为维护客户端和服务端的连接关系 Request Headers 一般包含以下部分(请求(客户端-&gt;服务端[request]))：GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) Accept为客户端能接收的资源类型 Accept-Language为客户端接收的语言类型 Connection为维护客户端和服务端的连接关系 Host: localhost为连接的目标主机和端口号 Referer告诉服务器我来自于哪里 User-Agent为客户端版本号的名字 Accept-Encoding为客户端能接收的压缩数据的类型 If-Modified-Since为缓存时间 Cookie为客户端暂存服务端的信息 Date为客户端请求服务端的时间&nbsp;&nbsp;&nbsp;&nbsp;而我们需要做的就是模拟浏览器提交Requests Headers获取服务器的响应信息,从而得到我们想要的数据，想要深入了解的读者请访问HTTP|MDN文档了解更多信息。使用 requests 库抓取网站数据 Requests库，官方文档是这样描述：Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。爬虫的原理就是进行HTTP请求然后得到响应，在响应中提取我们想要的信息并保存。而Requests库就是利用Python模拟HTTP请求的利器。如果读者已经安装了Anaconda，那么Requests库就已经可用了，如果没有Requests库，读者可以在命令行中（win+R 输入 cmd）pip install requests 安装requests库，接下来就开始我们的第一个请求吧！使用Requests发送HTTP请求非常简单，接下来我们就以GitChat为例： 12345678# 导入requests 模块import requests# 发起Get请求并返回Response对象，包含服务器对HTTP请求的响应response = requests.get(&apos;https://gitbook.cn/&apos;)# 打印 响应状态码print(response.status_code)# 打印 str类型的响应体，比如一个普通的 HTML 页面，需要对文本进一步分析时，使用 textprint(response.text) 运行结果是页 HTML 代码，我们就是从这样响应界面的内容进行信息的提取。 Requests不仅支持Get方式请求，比如Post请求： 12345678910# 导入 requests 模块import requests# 需要提交的表单数据data = &#123; &apos;name&apos;: &apos;ruo&apos;, &apos;age&apos;: 22&#125;# 发起Post请求response = requests.post(&quot;http://httpbin.org/post&quot;, data=data)# 响应体内容print(response.text) 运行结果： 使用 Beautiful Soup 解析网页提取信息接下来就是将响应的页面进行信息提取，常用如下两种方法：1.正则表达式；2.Xpath。 正则表达式 正则表达式是一个很强大的字符串处理工具，几乎任何关于字符串的操作都可以使用正则表达式来完成，作为一个爬虫工作者，每天和字符串打交道，正则表达式更是不可或缺的技能。有了它，从HTML里提取想要的信息就非常方便了。初次接触正则表达式的读者可能会觉得有些抽象，有点难入门，因为毕竟正则表达式本身就是一种小型的、高度专业化的编程语言，以上的入门教程了解后，这里给读者介绍一个提取信息通用的正则字符串 .*?，该规则能够以非贪婪的方式匹配任意字符，后面我们会经常使用到。比如我们需要匹配 “&lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt;” 标签中的内容，我们可以:123456789101112# 导入 re 模块import re# 待匹配文本h1 = &apos;&lt;H1&gt;Chapter 3.2.1 - 介绍正则表达式&lt;/H1&gt;&apos;# 将正则字符串编译成正则表达式对象，方便在后面的匹配中复用pat = re.compile(&apos;&lt;H1&gt;(.*?)&lt;/H1&gt;&apos;, re.S)# re.search 扫描整个字符串并返回第一个成功的匹配result = re.search(pat, h1)# 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。print(result.group(0))# 匹配的第一个括号内的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。print(result.group(1)) 结果： Xpath XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。 起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型，但是XPath很快的被开发者采用来当作小型查询语言，在爬虫中提取信息也是不错的好帮手。 我们可以通过浏览器检查提供的工具直接获取对应节点的Xpath规则，从而达到快速利用Xpath提取网页信息的目的，例如提取猫眼电影TOP100榜中的电影信息，首先打开浏览器输入http://maoyan.com/board/4，将鼠标移动到需要提取的信息（电影名称）上，右键选择检查，如下图所示： 123456789101112131415161718192021import requests# 导入lxml库的etree模块from lxml import etreeheaders = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;&#125;url = &apos;http://maoyan.com/board/4&apos;response = requests.get(url, headers=headers)html = response.text# 调用HTML类进行初始化html = etree.HTML(html)# 粘贴我们copy的xpath，提取电影名 “霸王别姬”result_bawangbieji = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd[1]/div/div/div[1]/p[1]/a&apos;)# 打印节点标签包含的文本内容print(result_bawangbieji[0].text)# 提取该页面所有电影名，即选择所有&apos;dd&apos;标签的电影名result_all = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd/div/div/div[1]/p[1]/a&apos;)# 打印所有提取出的电影名print(&apos;该页面全部电影名：&apos;)for one in result_all: print(one.text) 结果如下： 存储信息默认都是与当前项目在同级目录下。 TEXT文本存储123456789101112131415161718192021222324import requestsfrom lxml import etreeheaders = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;&#125;url = &apos;http://maoyan.com/board/4&apos;response = requests.get(url, headers=headers)html = response.text# 调用HTML类进行初始化html = etree.HTML(html)# 粘贴我们copy的xpath，提取电影名 “霸王别姬”result_bawangbieji = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd[1]/div/div/div[1]/p[1]/a&apos;)# 打印节点标签包含的文本内容print(result_bawangbieji[0].text)# 提取该页面所有电影名result_all = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd/div/div/div[1]/p[1]/a&apos;)# 打印所有提取出的电影名print(&apos;该页面全部电影名：&apos;)for one in result_all: print(one.text)# 将这一页电影名存储至TEXT文件中，&apos;a&apos; 指打开一个文件进行追加。 如果文件存在，则文件指针位于文件末尾。也就是说，文件处于追加模式。如果文件不存在，它将创建一个新文件进行写入。with open(&apos;film_name.text&apos;, &apos;a&apos;) as f: for one in result_all: f.write(one + &apos;\\n&apos;) CSV存储CSV文件即逗号分隔值（也称字符分隔值，因为分隔符可以不是逗号），是一种常用的文本格式，以纯文本形式存储表格数据，包括数字或者字符。Python中已经内置CSV文件操作的模块，只需要导入就可以进行CSV存储操作。123456789101112131415161718192021222324import requestsfrom lxml import etree# 导入CSV模块import csvheaders = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;&#125;url = &apos;http://maoyan.com/board/4&apos;response = requests.get(url, headers=headers)html = response.texthtml = etree.HTML(html)result_bawangbieji = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd[1]/div/div/div[1]/p[1]/a&apos;)print(result_bawangbieji[0].text)result_all = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd/div/div/div[1]/p[1]/a&apos;)print(&apos;该页面全部电影名：&apos;)for one in result_all: print(one.text)# 将这一页电影名存储至CSV文件中：with open(&apos;film_name.csv&apos;, &apos;a&apos;, newline=&apos;&apos;) as f: csv_file = csv.writer(f) for one in result_all: csv_file.writerow([one.text]) Mysql存储在Python2中，连接MySQL的库大多是使用MySQLdb，但是此库的官方并不支持Python3，所以这里推荐使用的库是PyMySQL，通过Python+MySQL数据库操作（PyMySQL）| Python教程学习PyMYSQL操作MySQL的相关方法和实例，接下来我们就尝试将Xpath提取的电影名存储到MySQL中，没有该模块的读者可以通过（win+R 输入 cmd）pip install pymysql 安装pymysql库。 123456789101112131415161718192021222324252627282930313233import requestsfrom lxml import etree# 导入pymysql模块import pymysql# 打开一个数据库连接db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, port=3306, db=&apos;spider&apos;, use_unicode=True, charset=&quot;utf8&quot;)# 获取MySQL的操作游标，利用游标来执行SQL语句cursor = db.cursor()headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;&#125;url = &apos;http://maoyan.com/board/4&apos;response = requests.get(url, headers=headers)html = response.texthtml = etree.HTML(html)result_bawangbieji = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd[1]/div/div/div[1]/p[1]/a&apos;)print(result_bawangbieji[0].text)result_all = html.xpath(&apos;//*[@id=&quot;app&quot;]/div/div/div[1]/dl/dd/div/div/div[1]/p[1]/a&apos;)print(&apos;该页面全部电影名：&apos;)for one in result_all: print(one.text) try: # 插入数据语句 sql = &apos;INSERT INTO film_infor(film_name) values (%s)&apos; cursor.execute(sql, (one.text)) db.commit() except: db.rollback() 爬虫攻防战","categories":[{"name":"爬虫实践","slug":"爬虫实践","permalink":"http://merlin153.com/categories/爬虫实践/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://merlin153.com/tags/爬虫/"}],"author":"merlin"},{"title":"TCP原理","slug":"TCP原理","date":"2019-05-08T10:44:59.000Z","updated":"2019-05-08T02:53:27.121Z","comments":true,"path":"2019/05/08/TCP原理/","link":"","permalink":"http://merlin153.com/2019/05/08/TCP原理/","excerpt":"","text":"TCP/IP 简介TCP/IP 起源于 60 年代末美国政府资助的一个分组交换网络研究项目，到 90 年代已发展成为计算机之间最常应用的组网形式。 计算机结构分层首先熟悉下计算机网络体系的结构分层，由图可以看出，在OSI参考模型下更注重”通信协议必要的功能是什么”，而TCP/IP强调”在计算机上实现协议应该开发哪种协议”，如图： 每一层负责的功能： 链路层(亦叫数据链路层或网络接口层)：通常包括操作系统中的设备驱动程序或计算机中对应的网络接口卡，它们一起处理与电缆(或其他传输媒介)的物理接口细节； 网络层(亦叫互联网层)：负责处理分组在网络中的活动，例如分组的选路。网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。 运输层：为两台主机上的应用程序提供端到端的通信。 应用层：负责处理特定的应用程序细节TCP/IP 包含的内容 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP/IP 是 IP 通信时所要用到的协议群的统称。往细里说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。 TCP 和 UDP 比较TCP特性 TCP 是一种面向连接的、可靠的字节流服务，也就是说只有在确认有通信对端存在时，才会发送数据； TCP仅仅是两方的彼此通信，广播和多播不能用于TCP； TCP使用校验和，确认和重传机制来保证可靠传输； TCP给数据分节进行排序，并使用累积确认以保证数据的顺序不变和非重复； TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口大小的方式进行。 UDP 特性提到TCP，就不得不说到 UDP，和 TCP 相比，UDP 具有如下特性： UDP 是利用 IP 提供面向无连接的，UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程； UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界； UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次，传输途中出现丢包，UDP 也不负责重发； 另外UDP支持多播和广播。 UDP 使用UDP 常用于一下几个方面： 1.包总量较少的通信（DNS、SNMP等）； 2.视频、音频等多媒体通信（即时通信）； 3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。 注意：TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。 TCP 的通信三次握手 握手 书面意义 目的意义 第一次握手 客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。 服务端得出结论:客户端的发信和服务端的收信是正常的 第二次握手 服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常 第三次握手 客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 问题 (ISN)是固定的吗？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 那么为什么TCP客户端最后还要发送一次确认呢？是为了解决什么问题呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因：建立三次握手主要是因为A发送了再一次的确认，那么A为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给B，从而产生了错误。所谓“已失效的连接请求报文”是这样产生的： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，A发出连接请求，但是因为连接报文请求丢失而未收到确认，于是A再重传一次连接请求，后来收到了请求，并收到了确认，建立了连接，数据传输完毕后，就释放链接，A共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”，但是还有异常情况下，A发送的请求报文连接段并没有丢失，而是在某个网络节点滞留较长时间，以致延误到请求释放后的某个时间到达B，本来是一个早已失效的报文段，但是B收到了此失效连接请求报文段后，就误以为A又重新发送的连接请求报文段，并发送确认报文段给A，同意建立连接，如果没有三次握手，那么B发送确认后，连接就建立了，而此时A没有发送建立连接的请求报文段，于是不理会B的确认，也不会给B发送数据，而B却一直等待A发送数据，因此B的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生，例如刚刚，A不理会B，就不会给B发送确认，B收不到A的确认，就知道A不要求建立连接，就不会白白浪费资源。 三次握手过程中可以携带数据吗？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。 四次挥手 挥手 书面意义 目的意义 第一次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 我客户端没数据要发给你了，如果你服务器端还有数据没有发送完成，可以继续发送数据 第二次挥手 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 服务器意图告诉客户端，你的请求我收到了，但是我还没准备好，请继续等我的消息 第三次挥手 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 告诉客户端，好了，我这边数据发完了，准备好关闭连接了 第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。 客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。 问题 为什么客户端最后还要等待2MSL(常问)？ MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 i. 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到。于是服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。 ii. 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 为什么不能用两次握手进行连接？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在把三次握手改成仅需要两次握手，死锁是可能发生的。假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理 又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手：此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源。 如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。","categories":[{"name":"TCP原理","slug":"TCP原理","permalink":"http://merlin153.com/categories/TCP原理/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://merlin153.com/tags/TCP/"}],"author":"merlin"},{"title":"虚拟内存和物理内存","slug":"虚拟内存和物理内存","date":"2019-04-11T10:54:24.000Z","updated":"2019-07-07T16:06:29.699Z","comments":true,"path":"2019/04/11/虚拟内存和物理内存/","link":"","permalink":"http://merlin153.com/2019/04/11/虚拟内存和物理内存/","excerpt":"","text":"问题来源在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多以下问题： 因为物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的；由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的；因为内存时随机分配的，所以程序运行的地址也是不正确的。 我们都知道一个进程是与其他进程共享CPU和内存资源的,所以操作系统需要有一套完善的内存管理机制才能防止进程之间内存泄漏的问题。 解决方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对以上出现的各种问题，为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），换句话说，这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的人会认为虚拟内存只是“使用硬盘空间来扩展内存“的技术，这是不对的。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，使得程序的编写难度降低。并且，把内存扩展到硬盘空间只是使用虚拟内存的必然结果，虚拟内存空间会存在硬盘中，并且会被内存缓存（按需），有的操作系统还会在内存不够的情况下，将某一进程的内存全部放入硬盘空间中，并在切换到该进程时再从硬盘读取（这也是为什么Windows会经常假死的原因…）。 ​ 虚拟内存在当前的Windows中，虚拟内存的方法有分页式和分段式两种。Windows采用的是分页式。该方式指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以页为单位在内存和磁盘间进行置换。在分页式中，把磁盘的内容读到内存中称为 Page In,把内存的内容写入到磁盘 Page Out。一般情况下，Windows 计算机的页的大小是4KB。也就是说，把大程序用4KB的页来进行切分，并以页为单位放入磁盘（虚拟内存）或内存中。 ​ 但是，如果认为虚拟内存就能解决内存不足的问题，那就错了，因为使用虚拟内存时发生的 Page In 和 Page Out 往往伴随着低俗的磁盘访问，因此这个过程中应用的运行时很迟钝的。换句话说，虚拟内存无法彻底解决内存不足的问题。另外一种方法就是将运行的应用文件变小，1. 通过DLL(Dynamic Link Library)文件实现函数共有；2. 通过调用 _stdcall 来见笑小程序文件的大小。 访问虚拟内存进程开始要访问一个地址，它可能会经历下面的过程： 每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址; 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上; 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录; 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）; 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常; 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。 可以看出虚拟内存主要提供了如下三个重要的能力： 它把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。 它为每个进程提供了一个一致的地址空间，从而降低了程序员对内存管理的复杂性。 它还保护了每个进程的地址空间不会被其他进程破坏。虚拟内存机制的优点 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系。 当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存。 在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存。 总结实际中，当内存不够使用时，可以借助虚拟内存运行程序。例如：在主机只剩下5MB内存空间的情况下也能运行10MB大小的程序。只不过，CPU只能执行加载到内存中的程序。虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在于内存中的。也就是说，为了实现虚拟内存，就必须把实际内存（也就是物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换，并同时运行程序。 推荐参考：[1]虚拟内存具体分析：https://www.cnblogs.com/dyllove98/archive/2013/06/12/3132940.html [2]内存分配问题：https://juejin.im/post/59f8691b51882534af254317","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://merlin153.com/categories/计算机基础/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://merlin153.com/tags/计算机/"},{"name":"内存","slug":"内存","permalink":"http://merlin153.com/tags/内存/"}],"author":"merlin"},{"title":"Git常用语法","slug":"Git常用语法","date":"2019-04-10T10:02:50.000Z","updated":"2019-04-10T02:03:58.029Z","comments":true,"path":"2019/04/10/Git常用语法/","link":"","permalink":"http://merlin153.com/2019/04/10/Git常用语法/","excerpt":"","text":"Git常用命令Git是目前世界上最先进的分布式版本控制系统，由Linux开源社区开发，最初设计摸底是为了方便管理Linux内核的开发。 新建代码库 命令 含义 git init 在当前目录创建一个Git代码库 git init [project-name] 新建一个目录，将其初始化为Git代码库 git clone [url] 下载一个项目和它的整个代码历史 配置 命令 含义 git config –list 显示当前的Git配置 git config -e [–global] 编辑Git配置文件 git config [–global] user.name “[username]” 设置提交代码时的用户信息 git config [–global] user.email “@email” 同上 增加/删除文件 命令 含义 git add [file1] [file2] … 添加指定文件到暂存区 git add [dir] 添加指定目录到暂存区，包括子目录 git add 添加当前目录的所有文件到暂存区 git add -p 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] 删除工作区文件，并且将这次删除放入暂存区 git rm -cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 代码提交 命令 含义 git commit -m [message] 提交暂存区到仓库区 git commit [file1] [file2].. -m “message” 提交暂存区的指定文件到仓库区 git commit -a 提交工作区自上次commit之后的变化，直接到仓库区 git commit -v 提交时显示所有diff信息 git commit –amend -m [message] 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit –amend [file1] [file2] … 重做上一次commit，并包括指定文件的新变化 分支 命令 含义 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch [branch-name] 新建一个分支，但依然停留在当前分支 git checkout -b [branch] 新建一个分支，并切换到该分支 git branch [branch] [commit] 新建一个分支，指向指定commit git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] 切换到指定分支，并更新工作区 git checkout - 切换到上一个分支 git branch –set-upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间 git merge [branch] 合并指定分支到当前分支 git cherry-pick [commit] 选择一个commit，合并进当前分支 git branch -d [branch-name] 删除分支 git push origin –delete [branch-name] 删除远程分支 git branch -dr [remote/branch] 删除远程分支 标签 命令 含义 git tag 列出所有tag git tag [tag] 新建一个tag在当前commit git tag [tag] [commit] 新建一个tag在指定commit git tag -d [tag] 删除本地tag git push origin :refs/tags/[tagName] 删除远程tag git show [tag] 查看tag信息 git push [remote] [tag] 提交指定tag git push [remote] –tags 提交所有tag git checkout -b [branch] [tag] 新建一个分支，指向某个tag 查看信息 命令 含义 git status 显示有变更的文件 git log 显示当前分支的版本历史 git log –stat 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] 搜索提交历史，根据关键词 git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD –grep feature 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 git log –follow [file] 显示某个文件的版本历史，包括文件改名 git whatchanged [file] 显示某个文件的版本历史，包括文件改名 git log -p [file] 显示指定文件相关的每一次diff git log -5 –pretty –oneline 显示过去5次提交 git shortlog -sn 显示所有提交过的用户，按提交次数排序 git blame [file] 显示指定文件是什么人在什么时间修改过 git diff 显示暂存区和工作区的差异 git diff –cached [file] 显示暂存区和上一个commit的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git diff [first-branch]…[second-branch] 显示两次提交之间的差异 git diff –shortstat “@{0 day ago}” 显示今天你写了多少行代码 git show [commit] 显示某次提交的元数据和内容变化 git show –name-only [commit] 显示某次提交发生变化的文件 git show [commit]:[filename] 显示某次提交时，某个文件的内容 git reflog 显示当前分支的最近几次提交 远程同步 命令 含义 git fetch [remote] 下载远程仓库的所有变动 git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库的信息 git remote add [shortname] [url] 增加一个新的远程仓库，并命名 git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] 上传本地指定分支到远程仓库 git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突 git push [remote] –all 推送所有分支到远程仓库 撤销 命令 含义 git checkout [file] 恢复暂存区的指定文件到工作区 git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区 git checkout . 恢复暂存区的所有文件到工作区 git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset –hard 重置暂存区与工作区，与上一次commit保持一致 git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset –hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset –keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git revert [commit] 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支 git stash 暂时将未提交的变化移除，稍后再移入 git stash pop 同上 其他1git archive #生成一个可供发布的压缩包","categories":[{"name":"Git","slug":"Git","permalink":"http://merlin153.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://merlin153.com/tags/Git/"}],"author":"merlin"},{"title":"Git简介","slug":"Git简介","date":"2019-04-10T09:56:50.000Z","updated":"2019-04-10T01:59:08.093Z","comments":true,"path":"2019/04/10/Git简介/","link":"","permalink":"http://merlin153.com/2019/04/10/Git简介/","excerpt":"","text":"Git是目前世界上最先进的分布式版本控制系统，由Linux开源社区开发，最初设计摸底是为了方便管理Linux内核的开发。大型开源项目linux kernel、Android、chromium、mono、dotnet、UE4等都使用Git管理项目 版本控制系统如果你用Word写过长篇文稿，那你一定有这样的经历：修改了其中一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档就会产生很多副本。然后过了一周，你突然想找回被修改的文字，但已经记不清修改前保存在哪个文件里了，只好一个一个文件去找，焦躁并且愤怒着。看着桌面一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，心情郁闷。如果有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你和她作了哪些改动，得把你的改动和她的部分合并，这样效率就低了很多。于是你期望，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这样就出现了版本控制系统，用于记录文件的每次操作。 集中式版本控制系统最早出现的是集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，就会受限于互联网网速，当工程比较大时，这种方法就会严重滞后系统开发速率。 分布式版本控制系统那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 集中式和分布式各自的产品集中式免费：CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。收费 :比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），微软的VSS等 分布式促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 集中式VS分布式和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 Git由来Git 在设计之初就制订了若干目标：速度 、 简单的设计 、 对非线性开发模式的强力支持（允许上千个并行开发的分支）、完全分布式、有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）。Git 和其他版本控制系统（如 CVS）有不少的差别，Git 本身关心文件的整体性是否有改变，但多数的 CVS 或 SVN(Subversion的简称) 系统则在乎文件内容的差异。因此 Git 更像一个文件系统，直接在本机上获取数据，不必连接到主机端获取数据。自诞生于 2005 年以来，Git 日臻成熟完善，迅速成为最流行的分布式版本控制系统，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 Git优点相比集中式控制版本，Git有如下几个优点： 本地是版本库的完整镜像，因此支持离线工作 绝大多数操作都只需要访问本地文件和资源，而且与每个提交都是所有文件的完整副本，因此速度非常快。(PS:SVN等集中式版本控制系统存储每个文件与初始化版本的差异,而Git每个提交都是所有文件的完整副本，使得Git在回溯到某个提交时，不会对所有文件执行差异计算还原，因此速度会非常快) 强大快捷的分支功能，非常适合非线性开发过程。","categories":[{"name":"Git","slug":"Git","permalink":"http://merlin153.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://merlin153.com/tags/Git/"}],"author":"merlin"},{"title":"初学python(08--模块)","slug":"初学python-08-模块","date":"2019-04-09T22:40:40.000Z","updated":"2019-04-09T14:42:07.715Z","comments":true,"path":"2019/04/10/初学python-08-模块/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-08-模块/","excerpt":"","text":"模块的产生 Python 有一个交互式的解释器。在解释器中，你可以使用 Python 的所有功能。但是，解释器是一次性的。也就是说，如果你关掉解释器，那么先前定义、运行的一切东西，都会丢失不见。另一方面，在解释器中输入代码是一件很麻烦的事情；这是因为在解释器中实现复用代码方面比较困难。 因此为了提高代码复用率，把一组相关的 Python 相关的定义、声明保存在同一个 .py 文件中（很多编程语言都采用了这种编程思想）。此时，这个 Python 脚本就是一个 Python 模块（Module），因此一个.py文件就称之为一个模块（Module）。模块最大的好处是大大提高了代码的可维护性。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块，通过 import 载入定义好的 Python 模块。 或许你就有疑问，如果不同的人编写的模块名相同，Python会怎么处理？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。使用模块可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。模块识别（内部和初始化）待补充。。模块查看随着使用python的时间越来越长，安装的python模块也越来越多，如果想要查看一下自己安装的python模块，可用以下方法：通用帮助函数help() 在python命令行中键入help(),即可进入 help帮助文档界面继续输入你想查看的模块信息，比如modules，math等等 可以继续键入相应的模块名称得到该模块的帮助信息。 这是python的通用的查询帮助，可以查到几乎所有的帮助文档，但我们很多时候不需要这样层级式地向下查询，接下来会介绍如何直接查询特定的模块和函数帮助信息。 2. 直接使用 help(module_name) 使用help(module_name)时首先需要import该模块，有些教程中不进行导入而在模块名中加入引号help(‘module_name’)，这种方法可能会带来问题，大家可以用math模块测试，建议使用先导入再使用help()函数查询.12&gt;&gt;&gt; import math&gt;&gt;&gt; help(math) 3. 在python交互解释器下导入sys模块查看12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules.keys() 3. 查看内建模块sys.bultin_modulenames123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.builtin_module_names(&apos;_ast&apos;, &apos;_bisect&apos;, &apos;_codecs&apos;, &apos;_codecs_cn&apos;, &apos;_codecs_hk&apos;, ... &apos;zlib&apos;) 函数查询 查看模块下所有函数dir(module_name) 12&gt;&gt;&gt; dir(math)[&apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;,...] 查看模块下特定函数信息help(module_name.func_name) 123456&gt;&gt;&gt; help(math.sin)Help on built-in function sin in module math:sin(...) sin(x) Return the sine of x (measured in radians). 直接打印法:print(func_name.doc)12345678&gt;&gt;&gt; print(print.__doc__)print(value, ..., sep=&apos; &apos;, end=&apos;\\n&apos;, file=sys.stdout, flush=False)Prints the values to a stream, or to sys.stdout by default.Optional keyword arguments:...&gt;&gt;&gt;print(math.__doc__)This module is always available. It provides access to themathematical functions defined by the C standard.","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(07--函数)","slug":"初学python-07-函数","date":"2019-04-09T22:37:41.000Z","updated":"2019-04-09T14:38:34.842Z","comments":true,"path":"2019/04/10/初学python-07-函数/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-07-函数/","excerpt":"","text":"定义函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。12def 函数名（参数列表）: 函数体 #这里有缩进，一个Tab（4个空格） 函数传参 类型和变量的关系12a=[1,2,3]a=&quot;Runoob&quot; 上述代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可变参数和不可变参数 默认参数和不定长参数 特殊的带两个*的参数，也就是 **var 这样的参数 全局变量和局部变量","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(06--循环)","slug":"初学python-06-循环","date":"2019-04-09T22:35:44.000Z","updated":"2019-04-09T14:36:45.701Z","comments":true,"path":"2019/04/10/初学python-06-循环/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-06-循环/","excerpt":"","text":"while循环语法：12while 判断条件： 语句 #这里的句头有一个 Tab 空格，Tab=4 无限循环12while True: pass 这个语句在我个人看来，就是只要当前程序的这个语句之前能运行，那么这个语句就会执行，还句话说就是永为真，程序执行后按 Ctrl+c 可结束程序。 while 循环使用 else 语句123456count = 0while count &lt; 5: print (count, &quot; 小于 5&quot;) count = count + 1else: print (count, &quot; 大于或等于 5&quot;) 这个语句很少用，因为很多时候这种语句是可以用 for 循环代替的，但是这条语句表达的思想却没有问题 for循环for循环可以遍历任何序列的项目，如一个列表或者一个字符串。语法：1234for tempVar in seq: #tempVar是临时变量，相当于C、java中的 i pass #seq是序列，可以为列表、元组、字典等等else: pass range函数如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列。例如： 12345678910111213141516#例1：for i in range(5): print(i) #结果是列项输出0,1,2,3,4#例2：for i in range(7,13) : print(i) #结果是列项输出7,8,9,10,11,12,右侧边界值取不到 #例3：for i in range(0, 10, 3) : print(i) #结果：0,3,6,9#例4a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']for i in range(len(a)): #可以结合range()和len()函数以遍历一个序列的索引 print(i, a[i]) break因为本人接触过C语言、C++和java语言，所以比较熟悉，就不多说了，功能就是结束整个循环，并且后面的语句不执行。 continuecontinue就是跳出当前循环，执行下次循环","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(05--基本类型的使用)","slug":"初学python-05-基本类型的使用","date":"2019-04-09T22:32:32.000Z","updated":"2019-04-16T13:40:22.206Z","comments":true,"path":"2019/04/10/初学python-05-基本类型的使用/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-05-基本类型的使用/","excerpt":"","text":"数据基本分类 类别 成员 不可变类型 Number(数字),String(字符串),Tuple(元组) 可变类型 List(),Dictionary(字典),Set(集合) 不可变类型1.数字Number 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 访问：直接访问即可常用方法：| 方法 | 描述 ||–|–||abs()|返回数字的绝对值，如abs(-10) 返回 10 ||fabs(x)|返回数字的绝对值，如math.fabs(-10) 返回10.0||pow(x, y)|x**y运算后的值||round(x,n)|返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。| 随机函数|方法|描述||–|–||choice(seq)| 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。||random()| 随机生成下一个实数，它在[0,1)范围内。||seed([x])|改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。| random函数的使用random():随机生成下一个实数，它在[0,1)范围内。123456789101112131415161718192021222324252627#encoding==utf-8import random#random()方法print(&quot;输出一个random数1：&quot;,random.random())print(&quot;输出一个random数2：&quot;,random.random())# choice()方法print (&quot;从 range(100) 返回一个随机数 : &quot;,random.choice(range(100)))print (&quot;从列表中 [1, 2, 3, 5, 9]) 返回一个随机元素 : &quot;, random.choice([1, 2, 3, 5, 9]))print (&quot;从字符串中 &apos;Runoob&apos; 返回一个随机字符 : &quot;, random.choice(&apos;Runoob&apos;))#shuffle()方法list = [15,25,45,36]random.shuffle(list)print(&quot;随即列表结果:&quot;,list)random.shuffle(list)print(&quot;随即列表结果:&quot;,list)#randint(),返回整数print(&quot;随即一个整数（0-10）：&quot;,random.randint(0,10))print(&quot;随即一个整数（10-100）：&quot;,random.randint(10,100))#uniform()，返回的是浮点数print(&quot;随即一个范围数（1-10）：&quot;,random.uniform(1,10))print(&quot;随即一个范围数（20-100）：&quot;,random.uniform(20,100)) range()函数的使用range() 是 python 的内置函数，用于创建一个整数列表，一般用于 for 循环中。help(range)帮助文档如下：123456789class range(object) | range(stop) -&gt; range object | range(start, stop[, step]) -&gt; range object | | Return an object that produces a sequence of integers from start (inclusive) | to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. | start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. | These are exactly the valid indices for a list of 4 elements. | When step is given, it specifies the increment (or decrement). 使用方法：12345678910&gt;&gt;&gt;range(10) # 从 0 开始到 10[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; range(1, 11) # 从 1 开始到 11[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; range(0, 30, 5) # 步长为 5[0, 5, 10, 15, 20, 25]&gt;&gt;&gt; range(0, 10, 3) # 步长为 3[0, 3, 6, 9]&gt;&gt;&gt; range(0, -10, -1) # 负数[0, -1, -2, -3, -4, -5, -6, -7, -8, -9] 2.字符串访问方式：直接访问 [x:y]:截取字符串中的一部分，遵循左闭右开原则,结果是取不到尾标y的。（记忆从零计数开始，只到n-1） 123s='hello world'print(s[:7]) #结果为：hello w #空格也计数在内，n个空格就是n个字符 顺便区分下Python2和Python3的区别：Python2：raw_input()是对输入的字符串不作处理，input()会对字符串做处理。Python3：和Python2的raw_input()功能一致，对字符串不作处理 3.元组访问：123456789tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 ) print &quot;tup1[0]: &quot;, tup1[0] #和列表一样，通过下角标访问print &quot;tup2[1:5]: &quot;, tup2[1:5]结果：tup1[0]: physicstup2[1:5]: (2, 3, 4, 5) Python 的元组与列表类似，不同之处在于元组的元素不能修改。注意：元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用|操作|意义||–|–||访问元素| 和列表访问一样，通过索引即可实现|| 改变元素| 不允许改变元素，但是可以拼接元组，通过‘+’实现|| 删除元素| 不允许删除元素，但是可以通过del语句删除整个元组| 可变类型列表访问：123456789list1 = [&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000]list2 = [1, 2, 3, 4, 5, 6, 7 ] print &quot;list1[0]: &quot;, list1[0] #通过下角标(从0计数)访问，print &quot;list2[1:5]: &quot;, list2[1:5]结果：list1[0]: physicslist2[1:5]: [2, 3, 4, 5] 主要方法： 方法 含义 作用 list.append(obj) 在列表末尾添加新的对象 增 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 增 list.insert(index,obj) 将对象插入列表 增 list.pop(index) 移除列表中的一个元素，默认最后一个元素 删 list.remove(obj) 移除列表中某个值的第一个匹配项 删 list.clear() 清空列表 删 list.reverse() 方向列表元素 虚变 list.count(obj) 计算某个元素在列表中出现的次数 统计 list.index(obj) 在列表中找出某个值的第一个匹配项的索引位置 查询 字典字典是一种可变容器模型，且可存储任意类型对象，字典的每个键值(key=&gt;value)对用冒号“：”分割，每个对之间用逗号 “，” 分割，整个字典包括在花括号 “{}” 中。注意：键必须是唯一的，但值则不必，值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组，创建时如果同一个键被赋值两次，后一个值会被记住。 访问：12345678dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125; print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;]print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;]结果：dict[&apos;Name&apos;]: Zaradict[&apos;Age&apos;]: 7 操作 意义 增、改 都是定义新的键值，有则覆盖（即改变），无则增添 删 删除值：del dict[‘Name’]；清空字典：dict.clear() ；删除字典：del dict set集合集合（set）是一个无序的不重复元素序列，可以使用大括号 { } 或者 set() 函数创建集合，创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典访问：集合不能直接访问，可以使用 for 循环访问。123456789101112&gt;&gt;&gt; a = set(&apos;dsadfas&apos;)&gt;&gt;&gt; a&#123;&apos;d&apos;, &apos;a&apos;, &apos;f&apos;, &apos;s&apos;&#125;&gt;&gt;&gt; a[2]Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;set&apos; object does not support indexing&gt;&gt;&gt; for i in a:... print(i)...da 操作 意义 增 s.add(x)，增减元素x 删 s.remove(x)，元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。 删 s.discard(x)，删除元素x,即便元素不存在也不会发生错误 删 s.pop(),随机删除一个元素，返回该元素 其他 len(s)计算元素个数；s.clear()清空","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(04--基本操作)","slug":"初学python-04-基本操作","date":"2019-04-09T22:27:59.000Z","updated":"2019-04-09T14:29:04.846Z","comments":true,"path":"2019/04/10/初学python-04-基本操作/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-04-基本操作/","excerpt":"","text":"基础语法文件保存默认保存一般都是采取 xxx.py 的格式标准进行保存，也可以以其他文件形式保存，但推荐以 .py 结尾，以便其他文件识别，例如：若想实现如windows的 .exe 一样直接运行，最好在第一行添加此注释：1#!/usr/bin/env python3 注释 设置编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串， 当然你也可以为源码文件指定不同的编码，如果你是Python 2，则需要添加如下代码以实现输出汉语1#encoding=utf-8 在这里说明，编码设置必须放置第一行，当python解释器读到是以上代码时，会自动识别该文件的汉语并做处理 单行注释Python中单行注释以 # 开头，后跟内容 多行注释多行注释可以用多个 # 号，也可以 ‘’’ 和 “”” 标识符 第一个字符必须是字母或者下划线_ 标识符的其他的部分由字母、数字和下划线组成 标识符对大小写敏感（意思是例如Test和test函数是两个不同的函数） 关键字（保留字）关键字不能把它们用作任何标识符名称，通过keyword.kwlist可查询 首行缩进python能用首行缩进表示代码块，不恰当的缩进会导致程序错误。 数据类型Python3 中有六个标准的数据类型：不可变数据类型：Number（数字）、String（字符串）、Tuple（元组）可变数据类型：List（列表）、Set（集合）、Dictionary（字典） 数据类型的判断可通过instance和type来判断，区别在于：type()不会认为子类是一种父类类型。isinstance()会认为子类是一种父类类型。 注意：在 Python3 中，True 和 False 被定义成关键字了，但它们的值还是 1 和 0，而且它们可以和数字相加。 不可变类型 number类型int (整数)：如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。bool (布尔)： 如 True。float (浮点数)：如 1.23、3E-2complex (复数)： 如 1 + 2j、 1.1 + 2.2j 字符串（String） python中单引号和双引号使用完全相同 使用三引号(‘’’或”””)可以指定一个多行字符串。3.转义符 ‘\\‘4.反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。5.按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。6.字符串可以用 + 运算符连接在一起，用 * 运算符重复。7.Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。8.字符串的截取的语法格式：变量[头下标:尾下标:步长] 1234567891011121314151617181920212223242526def printExplain(): print(\"=\"*20)# 以下是测试内容print('你好')printExplain()print(\"你好\")printExplain()print(\"这句话含\\n有转义字符\")printExplain()print(r\"这句话加入了r\\n，使不发生转义\")printExplain()print(\"\"\"这是个多行字符\"\"\")printExplain()print(\"这段话通过\"+\"带+符号\"+\"实现\")print(\"这段话通过及联\"\"的方式实现\")printExplain()str=\"hello world\"strp=\"这是个字符串\"print(str[0:-1:2])print(strp[0:-1:2])printExplain() 运行结果为： 元组元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 注意：虽然tuple的元素不可改变，但==它可以包含可变的对象==，比如list列表。 可变类型 列表列表是写在方括号 [] 之间、用逗号分隔开的元素列表。和字符串一样，列表同样可以被索引和截取，==列表被截取后返回一个包含所需元素的新列表== 字典字典是一种映射类型，它的元素是键值对。字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。键(key)必须使用不可变类型，在同一个字典中，键(key)必须是唯一的。 ==和列表的区别==：列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 Set集合集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员，主要是为了进行成员关系测试和删除重复元素，可以使用大括号 { } 或者 set() 函数创建集合。 注意：：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。set集合在输出时会把重复元素弃掉，Set 集合可以进行计算：print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 用户输入(input)1input(&quot;please input:&quot;) 输出格式化输出：12print(&quot;姓名：%s&quot;%name)print(&quot;姓名：%s,专业：%s&quot;%(name,mejor)) print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=”” import和from import在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import *","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(02--Linux命令)","slug":"初学python-02-Linux命令","date":"2019-04-09T22:23:34.000Z","updated":"2019-04-09T14:26:43.900Z","comments":true,"path":"2019/04/10/初学python-02-Linux命令/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-02-Linux命令/","excerpt":"","text":"Linux命令格式：command [-options] [parameter1] （注：#皆为注释，不为代码内容，单词间有空格） 查看信息：ls12345ls --help #查看Linux自带的帮助信息，&quot;ls -h&quot;不能生效ls -lah #显示当前路径下的具体文件信息，l,a,h三个字母顺序无碍man ls #查看ls使用细则 man是manual（手册）之意man print 2 #打印相关命令，1：标准命令 2：系统调用 3：库函数 输出重定向：&gt;(覆盖),&gt;&gt;(追加)12ls &gt; test.txt #将ls出来的内容输入到test.txt文件中，覆盖原来的内容，若没有该文件则创建ls -alh &gt;&gt; test.txt #将ls -alh出来的内容追加到test.txt中 分屏和管道显示：|，more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助。12ls -alh | more #分屏显示cat test.txt | more #管道输入输出 目录创建和删除：mkdir目录的切换：12345pwd #查看当前所在路径cd ~ #切换到当前用户的主目录(/home/用户目录)cd . #切换到当前目录cd .. #切换到上级目录cd - #切换到上次所在的目录 创建和删除目录： 1234mkdir test #创建test文件夹mkdir a/b/c #递归创建a，b，c目录rmdir a #删除a目录。注意：必须离开目录，并且目录必须为空目录，不然提示删除失败 删除文件常用参数：-f：强制删除，忽略不存在的文件，无需提示；-r:递归地删除目录下的内容，删除文件夹时必须加此参数-i：可防止误删，用得少1rm test -rf #删除文件，rf一般一起用。 建立链接文件链接分为硬链接和软链接两种，硬链接相当于给源文件取了个别名，本质上还是一个文件，通过“ls -li”可查看两个链接文件的innode号，发现是一致的，在删除硬链接文件时，不会直接删除源文件，而是一个个删除，直至为0；而软链接却是相反的，查询可发现软链接的innode号不一致，而且生成软链接的数目不会增加，可以理解为建立软链接就是建立一个新文件12ln a alink #给a文件创建**硬链接**alinkln -s b blink #给b文件创建**软连接**blink 软硬链接，1列数字为innode 查看或者合并文件内容12cat text.txt #查看文件，将文件内容输出到显示屏上，区别于gedit编辑器cat 1.txt 2.txt &gt; 3.txt #将1.txt,2.txt两个文件内容合并为3.txt（1.txt内容在前，2.txt内容追加其后） 文本搜索:grepgrep [-选项] ‘搜索内容串’文件名,选项有如下：-v:显示不包含匹配文本的所有行（相当于求反）-n:显示匹配行及行号-i:忽略大小写用grep查询文件内容时会经常用到通配符，常用通配符有如下： 1grep -n &apos;ke?&apos; 1.txt #搜索以“ke?”3个字母结尾的行 文件搜索：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。1234find ./ -name test.sh #查找当前目录下所有名为test.sh的文件find ./ -name &apos;*.sh&apos; #查找当前目录下所有后缀为.sh的文件find ./ -name &quot;[A-Z]*&quot; #查找当前目录下所有以大写字母开头的文件find ./ -perm 0777 #查找当前目录下权限为 777 的文件或目录 拷贝文档：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，有如下几个参数：-a：该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。-f：已经存在的目标文件而不提示-i：交互式复制，在覆盖目标文件之前将给出提示要求用户确认-r: 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。-v：显示拷贝进度使用规范：cp “源文件” “目标目录”1cp test.txt testdir #将text.txt文件拷贝到testdir目录下 文件移动：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名，有如下几个参数-f：禁止交互式操作，如有覆盖也不会给出提示-i:确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件-v:显示移动进度12mv file1 file2 #将file1文件名改为file2mv file1 test/code #将file1文件移动到test/code目录下 归档管理：tartar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。tar命令很特殊，其参数前面可以使用“-”，也可以不使用。tar使用格式： tar [参数] 打包文件名 文件常用参数（注意：除了f需要放在参数的最后，其它参数的顺序任意。）：-c:生成档案文件，创建打包文件-v:列出归档解档的详细过程，显示进度-f:指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后-t: 列出档案中包含的文件-x:解开档案文件 文件解压缩：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。使用格式：gzip [-选项] 被压缩文件常用参数：-d:解压-f:压缩所有子目录tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。12gzip -r test.tar test.tar.gz #或者写成gzip test.tar ,两者都是压缩test.tar文件gzip -d test.tar.gz #解压test.tar.gz tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。压缩用法：tar cvzf 压缩包包名 文件1 文件2 …1tar zcvf test.tar.gz 111.py 112.py *.py #把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz 解压用法：tar zxvf 压缩包包名 -C 解压路径 gzip解压文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。压缩文件：zip [-r] 目标文件(没有扩展名) 源文件解压文件：unzip -d 解压后目录文件 压缩文件 查看指令位置： which1which ls #查看ls指令的位置","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学python(01--认识Linux)","slug":"初学python-01-认识Linux","date":"2019-04-09T22:04:26.000Z","updated":"2019-04-09T14:26:41.906Z","comments":true,"path":"2019/04/10/初学python-01-认识Linux/","link":"","permalink":"http://merlin153.com/2019/04/10/初学python-01-认识Linux/","excerpt":"","text":"（注：本人是初学小白，记录笔记于此以便查看）windows作为最广泛的傻瓜式系统，为很多国内外用户的喜欢，它提供很简单易操作的功能，例如（安装程序，编写文案等方面，只需双击即可），但是在很多的实际开发中，尤其在选择系统做服务器中，考虑到便捷安全等各方面的因素，此以Linux为核心的操作系统受到广大开发人员的喜爱，而windows却不能兼具这样的功能。 区别首先对windows和Linux的目录分级进行了解：windows在实际生活中很常见，目录结构就不在此细说。可能唯一需要了解的就是，在长期的使用习惯中，人们把C盘独立出来，并不代表C盘不能装东西。C盘又叫启动盘，和其他盘一样可以装软件装资料，只是因为启动windows系统时，计算机需要访问C盘中的启动程序，当C盘装了太多资料软件时会影响启动速率，而这个时间上主要是在查找文件的开销上。再来看看Linux：Linux 系统是一套免费使用和自由传播的类 Unix 操作系统（主要用在服务器上），是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的UNIX 工具软件、应用程序和网络协议，支持 32 位和 64 位硬件。 Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。严格来说，Linux不是一个操作系统，只是一个操作系统的内核。如下图： 基于Linux内核的操作系统有很多，下图是发行中主流的一些：主流的Linux操作系统 这里以Ubuntu操作系统为例，下图是Ubuntu的文件目录结构： 文件作用：/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。 /bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等（常用指令皆是调用这里的文件）。 /boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。 /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。 /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，表示当前用户的家目录，edu 表示用户 edu 的家目录。 /lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。 /opt：给主机额外安装软件所摆放的目录。 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。 /root：系统管理员root的家目录。 /sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。 /usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 /var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。可见Linux操作系统的文件系统和windows操作系统是有很大区别的，在指令操作上也有很大差异。 在Ubuntu虚拟机系统中，升级系统时可参考此链接以此升级Linux系统，注意：当出现没有“curl”指令时，先安装curl. 参考文章：https://www.cnblogs.com/liuwei6/p/6661997.html","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"Pycharm个性设置","slug":"Pycharm个性设置","date":"2019-04-08T22:56:17.000Z","updated":"2019-04-08T15:13:28.363Z","comments":true,"path":"2019/04/09/Pycharm个性设置/","link":"","permalink":"http://merlin153.com/2019/04/09/Pycharm个性设置/","excerpt":"","text":"早期学语言的时候我一直都认为编辑器或者说IDE就是一种生产代码的软件，现在渐渐明白其实IDE也就是个能让你提高工作和管理的可视化软件，其本身对你工程并没有什么其他额外的作用。本质上，你所做的工程都是由一对对文件构成的，因为里面的调用关系才让软件看起来和“活”了一般。说了工程的本质，目的也是希望各路大神不要把IDE作为一种依赖工具，根据自己需求使用就好。所以在这里简单记录下编辑Python工程的IDE软件–Pycharm（目前还在使用中，后面会不断更新自定义的使用操作……）。 Pycharm是由Jetbrains开发的优秀的Python IDE。正如所有其它 JetBrains 集成开发环境一样，PyCharm 具有智能代码编辑器，能理解 Python 的特性并提供卓越的生产力推进工具：自动代码格式化、代码完成、重构、自动导入和一键代码导航等。这些功能在先进代码分析程序的支持下，使 PyCharm 成为 Python 专业开发人员和刚起步人员使用的有力工具。 配置编辑窗口配置代码颜色 方式一：如果不想自定义设置，可以参考这个链接，喜欢的话点击这里下载Jetbrains的全家桶包，里面有两个jar包，配置Pycharm就选在Pycharm的jar包，选全家桶的也没关系，因为是jar包，所以直接导入，操作是（file-&gt;import setting-&gt;color scheme font(或者python)，不满意可以微微修改。（不想麻烦也可以在百度网盘下载（链接: 链接：https://pan.baidu.com/s/14En5fMSs4O7Nd6_9U1vMKw提取码：obhr 复制这段内容后打开百度网盘手机App，操作更方便哦）） 方式二 可以去网上找一些Pycharm代码主题风格的配置文件(以 .icls格式结尾的)，也可以参考我这里(链接：https://pan.baidu.com/s/1llVOJdO3ta8C_jb5ANEhng提取码：0kaf 复制这段内容后打开百度网盘手机App，操作更方便哦)的，应用主题可以直接将主题复制到 C:\\Users\\Administrator.PyCharm2017.2\\config\\colors 这个目录下，或者也可以导入进来，参考下图： 配置代码背景颜色File -&gt; setting -&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Text -&gt; Default text,然后自行选择颜色。 显示代码行号行号设置：File -&gt; setting -&gt; Editor -&gt; General -&gt; Appearance -&gt; show line numbers 设置字体属性File -&gt; setting -&gt; Editor -&gt; Color Scheme -&gt; Color Scheme Font,然后自行设置 如果还有喜欢的个性配置，还会继续更新。。。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"初学Python(01--基础)","slug":"初学Python","date":"2019-04-02T09:53:13.000Z","updated":"2019-04-09T14:10:57.826Z","comments":true,"path":"2019/04/02/初学Python/","link":"","permalink":"http://merlin153.com/2019/04/02/初学Python/","excerpt":"","text":"基础语法注释 设置编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串， 当然你也可以为源码文件指定不同的编码，如果你是Python 2，则需要添加如下代码以实现输出汉语1#encoding=utf-8 在这里说明，编码设置必须放置第一行，当python解释器读到是以上代码时，会自动识别该文件的汉语并做处理 单行注释Python中单行注释以 # 开头，后跟内容 多行注释多行注释可以用多个 # 号，也可以 ‘’’ 和 “””标识符 第一个字符必须是字母或者下划线_ 标识符的其他的部分由字母、数字和下划线组成 标识符对大小写敏感（意思是例如Test和test函数是两个不同的函数） 关键字（保留字）关键字不能把它们用作任何标识符名称，通过keyword.kwlist可查询首行缩进python能用首行缩进表示代码块，不恰当的缩进会导致程序错误。数据类型Python3 中有六个标准的数据类型：不可变数据类型：Number（数字）、String（字符串）、Tuple（元组）可变数据类型：List（列表）、Set（集合）、Dictionary（字典） 数据类型的判断可通过instance和type来判断，区别在于：type()不会认为子类是一种父类类型。isinstance()会认为子类是一种父类类型。 注意：在 Python3 中，True 和 False 被定义成关键字了，但它们的值还是 1 和 0，而且它们可以和数字相加。 可变类型 number类型int (整数)：如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。bool (布尔)： 如 True。float (浮点数)：如 1.23、3E-2complex (复数)： 如 1 + 2j、 1.1 + 2.2j 字符串（String） python中单引号和双引号使用完全相同 使用三引号(‘’’或”””)可以指定一个多行字符串。3.转义符 ‘\\‘4.反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。5.按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。6.字符串可以用 + 运算符连接在一起，用 * 运算符重复。7.Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。8.字符串的截取的语法格式：变量[头下标:尾下标:步长] 1234567891011121314151617181920212223242526def printExplain(): print(\"=\"*20)# 以下是测试内容print('你好')printExplain()print(\"你好\")printExplain()print(\"这句话含\\n有转义字符\")printExplain()print(r\"这句话加入了r\\n，使不发生转义\")printExplain()print(\"\"\"这是个多行字符\"\"\")printExplain()print(\"这段话通过\"+\"带+符号\"+\"实现\")print(\"这段话通过及联\"\"的方式实现\")printExplain()str=\"hello world\"strp=\"这是个字符串\"print(str[0:-1:2])print(strp[0:-1:2])printExplain() 运行结果为： 元组元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。注意：虽然tuple的元素不可改变，但==它可以包含可变的对象==，比如list列表。 列表列表是写在方括号 [] 之间、用逗号分隔开的元素列表。和字符串一样，列表同样可以被索引和截取，==列表被截取后返回一个包含所需元素的新列表== 字典字典是一种映射类型，它的元素是键值对。字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。键(key)必须使用不可变类型，在同一个字典中，键(key)必须是唯一的。==和列表的区别==：列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 Set集合集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员，主要是为了进行成员关系测试和删除重复元素，可以使用大括号 { } 或者 set() 函数创建集合。注意：：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。set集合在输出时会把重复元素弃掉，Set 集合可以进行计算：print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 用户输入(input)1input(&quot;please input:&quot;) 输出格式化输出：12print(&quot;姓名：%s&quot;%name)print(&quot;姓名：%s,专业：%s&quot;%(name,mejor)) print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=”” import和from import在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule从某个模块中导入某个函数,格式为： from somemodule import somefunction从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc将某个模块中的全部函数导入，格式为： from somemodule import *","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://merlin153.com/categories/Python学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://merlin153.com/tags/Python/"}],"author":"merlin"},{"title":"Markdown 语法","slug":"markdown语法","date":"2019-03-26T17:04:05.000Z","updated":"2019-07-08T07:59:46.310Z","comments":true,"path":"2019/03/27/markdown语法/","link":"","permalink":"http://merlin153.com/2019/03/27/markdown语法/","excerpt":"","text":"目录1234* 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格.效果图： 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 样式如下：效果图： 字体格式1234*斜体方式1* 或 _斜体方式2_ **粗体** ***加粗斜体*** ~~删除线~~ 效果图: 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中内容的跳转。比如我们经常读的论文或者PDF，里面就包含着丰富的锚点，其中的目录就是锚点，点击一个章节就能快跳到对应文本内容，以此实现文章内部内容的跳跃。12345678910* [目录1](#40) * [标题1](#41) * [标题2](#42) * [标题3](#43)&lt;h3 id=\"41\"&gt;标题1&lt;/h3&gt; 我是标题1的内容&lt;h3 id=\"42\"&gt;标题2&lt;/h3&gt; 我是标题2的内容&lt;h3 id=\"43\"&gt;标题3&lt;/h3&gt; 我是标题3的内容 效果图： 超链接 行内式（用的较多）：1欢迎来到[google](www.google.com) 语法：[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接地址与链接标题前有一个空格。 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。1&lt;http://www.merlin153.com/&gt; 效果：http://www.merlin153.com/ 列表 常用列表123456789101112# 有序列表，使用数字、英文句点即可1. 有序列表一2. 有序列表二3. 有序列表三# 无序列表，使用 - ，+ ， * 都可表示无序列表 - 无序列表一+ 无序列表二- 无序列表三# 任务列表，要创建任务列表，前缀列表项[ ]。要将任务标记为完整，请使用[x]- [x] 文本一- [ ] 文本二- [ ] 文本三 效果图： 定义型列表12345名词1: 定义 1（左侧有一个可见的冒号和四个不可见的空格）代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 效果图： 列表缩进列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。12* 这是第一段，当文章很长的时候才能看出来他的缩进效果，其实这种缩进看起来更像是一种无序列表，所以就当无序列表使用吧！* 这是第二段，当文章很长的时候才能看出来他的缩进效果，其实这种缩进看起来更像是一种无序列表，所以就当无序列表使用吧！ 效果图： 图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。（注：图片链接可通过图床获取，比较好用的图床有SM.MS, 七牛图床等等） 行内式（常用） 1![图片标记内容](图片地址) 参考式 12在文档要插入图片的地方写![图片名称][标记]在文档的最后写上[标记]:图片地址 “Title” 图片的效果就没必要演示了，正确的语法就能实现。 引用只需在前面加上 &gt; 符号即可实现，引用也可以嵌套123&gt; 这是引用&gt;&gt; 这是引用嵌套&gt;&gt;&gt;多层嵌套 效果图： 代码段通过三个 · 或者 ~ 实现，也可以实现包裹代码，在第一个 ~~~ 的后面紧跟语言名称可实现智能识别，以便实现代码高亮风格。1234```~~~pythonprint(&quot;hello world&quot;)~~~ 效果：1print(\"hello world\") 表格123|name|age||:-|-:||内容|意义。。| 表格第一栏填写名称，第二栏可以在两个 | 之间添加 - 实现表格，再在 - 左右两边添加 : 实现内容向左右边靠。效果图：| name | age || :— | ——-: || 内容 | 意义。。 || 内容 | 意义。。 | 脚注在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。效果：比如点击这里^[1]，会跳转到底部 流程图Markdown也可以实现流程图绘制，更多语法参考：流程图语法参考 LaTeX 公式抱歉很少用到，可能论文上用的多吧，如果需要可以参考There { 基础语法感觉就够用了，流程图截图就好了，后续更新中。。。 } 参考文章:^[1]:Demi的技术空间^[3]:Coding下的markdown语法^[4]:文图详解请参考这里","categories":[{"name":"markdown语法","slug":"markdown语法","permalink":"http://merlin153.com/categories/markdown语法/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://merlin153.com/tags/markdown/"},{"name":"博客","slug":"博客","permalink":"http://merlin153.com/tags/博客/"}],"author":"merlin"},{"title":"博客搭建记录","slug":"博客搭建记录","date":"2019-03-26T17:04:05.000Z","updated":"2019-04-01T16:07:03.740Z","comments":true,"path":"2019/03/27/博客搭建记录/","link":"","permalink":"http://merlin153.com/2019/03/27/博客搭建记录/","excerpt":"","text":"此文是对基于windows的博客搭建流程的描述,采用的是hexo+GithubPages+域名的实现方案。 原理属性介绍 GithubPages是Github提供的一种空间托管服务，但是只能托管静态文件，对于写博客足以，静态文件支持html、css这些常见的网页件，Markdown文件、Jekyll文件，并不支持PHP这种动态脚本. 补充：GitHubPages为了提供对HTML内容的支持，选择了Jekyll作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看Jekyll官方文档Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过layout将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。jekyll的大致目录如下： 使用hexo做静态博客有个比较麻烦的地方是，hexo本身的博客源码是基于node.js的，直接将源码放在github上是不能解析的，必须用命令 hexo generate(也可以简写：hexo g) 生成public文件，public文件里面是html、css文件，然后将其部署到github的username.github.io项目的master分支下，同时在source目录下添加CNAME文件（CNAME里面记录自定义的域名），这样hexo会把CNAME文件放到网站根目录下。 大致原理这里简单地解析下GithubPages的基本原理，以我的域名merlin153.com为例，这是我在Chrome浏览器里输入merlin153.com的时候，通过F12观察到的请求头header，注意在header里面有一个字段host，Github服务器正是通过host来判断应该向浏览器返回一个什么样的html页面。当然前提是我得把merlin.com这个域名的A记录指向github提供的服务器地址。github知道请求是要获取merlin153.com的首页，但是应该去哪个repository里面找呢？github服务器肯定有数据库存储了merlin153.com和repository的对应关系，这个对应关系肯定是添加CNAME文件的时候建立的,也就是通过CNAME触发这种关系。 搭建环境git的配置 小白安装极力推荐:windows下Git图形安装 第三方网站参考Runoob，我觉得这上面讲的也很细，关键有些小窍门，可以在这个网站对Git做更深入的了解。 查看官网安装Git官网安装Git安装完成后可以检查下是否安装成功： 通过右键直接查看，如果存在“git bash here”操作键则证明安装成功。 通过在DOS窗口的“git –version”指令查询Git版本nodejs的配置 小白安装请参考windows下nodejs图形安装 nodejs的安装可查看Runoob安装完成后一定要配置其全局变量，然后就可以通过查询其版本(node -v)以检查是否安装成功了。 域名 如果不想花钱购买域名也可以实现创建自己的网站，即采用“hexo+GithubPages”方式，用“username.github.io”的方式登录。但如果用自己喜欢的域名来登录，那将再好不过。购买域名的网站有很多，比较能够信任的有godaddy、namesilo、万网、aliyun、腾讯云等等，看自己意愿了。很多的国外域名购买时都会优惠一点，比我在namesilo购买域名时就优惠了1美元，在这里给大家分享个可以获得优惠码的网址：https://xianhuo.org/ 接下来就是解析域名了，解析就是域名到IP地址的转换过程。 在域名注册商那里注册了域名之后如何才能看到自己的网站内容呢，这就需要用一个专业术语叫“域名解析”的服务来为我们工作。 域名是为了方便记忆而专门建立的一套地址转换系统，要访问一台互联网上的服务器，最终还必须通过IP地址来实现，域名解析就是将域名重新转换为IP地址的过程。一个域名对应一个IP地址，一个IP地址可以对应多个域名；所以多个域名可以同时被解析到一个IP地址。域名解析需要由专门的域名解析服务器(DNS)来完成。 解析过程。比如，一个域名为：aaa.com，如果要访问该网站，就要进行解析，首先在域名注册商如阳光互联等那里通过专门的DNS服务器解析到一个WEB服务器的一个固定IP上：211.214.1.XXX，然后，通过WEB服务器来接收这个域名，把aaa.com这个域名映射到这台服务器上。那么，输入aaa.com这个域名就可以实现访问网站内容了.即实现了域名解析的全过程. 人们习惯记忆域名，但机器间互相只认IP地址，域名与IP地址之间是对应的，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。 域名解析协议（DNS）用来把便于人们记忆的主机域名和电子邮件地址映射为计算机易于识别的IP地址。DNS是一种c/s的结构，客户机就是用户用于查找一个名字对应的地址，而服务器通常用于为别人提供查询服务 如何实现在注册商那里管理域名，需要添加两条记录，即：A记录和CNAME记录。同时你的博客站点目录的source文件夹下必须创建创建一个名字CNAME的文件，里面只需要记录你的域名。 A记录(IP指向)：用来指定域名对应的IP地址记录。用户可以将该域名解析到自己的WEB SERVER上。同时也可以设置您域名的二级域名。 CNAME（别名指向）:用域名来代替IP地址。 图形操作可参考此作者 配置hexoHexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 在磁盘中新建一个文件夹blog，进入blog，右键‘git bash here’，执行命令安装hexo：npm install -g hexo 初始化hexohexo init 安装npm和hexonpm install 启动本地浏览hexo s即可看到本地预览界面，也就是hexo的默认主题界面，后面我们进行替换主题操作。 常用命令hexo clean –&gt;hexo generate –&gt;hexo deploy 使用个性主题&lt;= 待修改… =&gt;这里我推荐一些比较受宠的主题，有yilia，next，jekll等等，这些主题可以到hexo【主题】栏里搜索到，大家也可以在hexo主题里看到很多其他的主题,如果喜欢的话可以点进相关主题，然后进入他们的github进行clone即可。这里，我比较喜欢基于next主题的响应式主题–miho，因为简洁，更因为它给我的阅读体验比较好（比如能够迅速通过目录定位到内容，迅速直接地找到其他的标签内容等等），总体上来说提高了阅读效率。 应用主题 下载主题 1git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho 下在完后，会看到你的博客目录下bolg/themes有个miho的文件夹，这个文件夹就是你后面个性设置时经常操作的目录 应用主题在配置文件中修改：theme: miho在最后一行修改代码如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:merlin153/merlin153.github.io.git branch: master 三个参数的冒号后面都必须有个空格，‘repo’参数的后面填写自己前面建立的github仓库名。执行常用操作hexo clean–&gt;hexo g–&gt;hexo d ,然后再浏览器界面输入本地地址可以看到模板主题，即应用主题成功。 应用主题图片： 个性修改1.修改logo和背景图片2.修改右上角菜单主题配置文件中采用YAML语言配置信息，所以修改时注意YAML语言格式，每个配置项后面都有个空格3.修改社交栏 4.daovoice的增添首先在官网注册账号，邀请码填写“数值”，即可创建完成，这时会看到给你的app_id和user_id，然后在themes/hexo-theme-miho/layout/layout.ejs文件中追加如下js代码： 1234567891011121314151617181920212223242526272829&lt;% if (theme.daovoice) &#123; %&gt; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123; i[\"DaoVoiceObject\"]=r; i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date(); a=s.createElement(o),m=s.getElementsByTagName(o)[0]; a.async=1;a.src=g;a.charset=\"utf-8\"; m.parentNode.insertBefore(a,m)&#125; )(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/\" + \"&lt;%- theme.daovoice.app_id %&gt;\" + \".js\",\"daovoice\") &lt;/script&gt; &lt;script&gt; daovoice('init', &#123; app_id: \"&lt;%- theme.daovoice.app_id %&gt;\", user_id: \"&lt;%- theme.daovoice.user_id %&gt;\", email: \"&lt;%- theme.daovoice.email %&gt;\", name: \"&lt;%- theme.daovoice.name %&gt;\", signed_up: &lt;%- theme.daovoice.signed_up %&gt; &#125;); daovoice('update'); &lt;/script&gt; &lt;script&gt; daovoice('init', &#123; app_id: \"&lt;%- theme.daovoice_app_id %&gt;\" &#125;); daovoice('update'); &lt;/script&gt;&lt;% &#125; %&gt; 最后修改miho的主题文件，追加如下代码，两个id填写刚才你在daovoice看到的值： 12345678# 在线联系 | DaoVoicedaovoice: enable: true app_id: #必填 user_id: # 必填: 该用户在您系统上的唯一ID email: # 选填: 该用户在您系统上的主邮箱 name: # 选填: 用户名 signed_up: 1449821660 # 选填: 用户的注册时间，用Unix时间戳表示 5.增加评论功能比较评论系统插件，来必力/livere、gitment、畅言、Valine都各具优势，【图片】，来必力和畅言都差不多，这里选畅言做评论插件吧。 先去畅言官网注册账号具体过程可参考畅言注册 然后进入 themes/miho/_config.yml 填写自己的appid和appkey，appid和appkey可以在畅言控制台的最下面看到。 至此，一个博客的模板就基本完成了，剩下的就是写博文了。博文书写工具推荐使用markdown。 常用操作 常用： hexo clean: hexo g :生成静态文件，会在当前目录下生成一个新的叫做public的文件夹(也可使用hexo generate) hexo s :启动本地服务，可以在http://localhost:4000/ 查看（也可使用hexo server） hexo d:部署到github远端 hexo new “pageName” #新建文章 hexo new page “pageName” #新建页面 组合操作hexo d -g #生成部署hexo s -g #生成预览","categories":[{"name":"博客","slug":"博客","permalink":"http://merlin153.com/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://merlin153.com/tags/博客/"},{"name":"hexo主题","slug":"hexo主题","permalink":"http://merlin153.com/tags/hexo主题/"}],"author":"merlin"},{"title":"神奇的vi编辑器","slug":"数据库发展","date":"2019-03-25T15:25:46.000Z","updated":"2019-03-26T09:19:51.539Z","comments":true,"path":"2019/03/25/数据库发展/","link":"","permalink":"http://merlin153.com/2019/03/25/数据库发展/","excerpt":"","text":"所有的Linux发行版系统上都会默认内置vi编辑器，而不一定带有其他文本编辑器，非常通用；其次，很多软件的编辑接口都会默认调用vi；再者就是对很多热爱编程的大佬来说，可大大提高编程效率，很多黑客也是使用这个编辑器来减少自己摸鼠标时间的。 VI命令的工作模式更详细的文档请参考：http://c.biancheng.net/view/519.html 或 http://www.runoob.com/linux/linux-vim.html简化图： vi编辑器有三种工作模式：命令模式、插入模式、末行模式。 命令模式：此时从键盘上输入的任何字符都被当做编辑命令来解释，同时该模式是进入 vi 编辑器后的默认模式。任何时候，不管用户处于何种模式，按下Esc键即可进入命令模式。 插入模式（亦称编辑模式）：在命令模式下输入插入命令i、附加命令a、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被 vi 当做文件内容保存起来，并将其显示在屏幕上。 末行模式（亦称ex 转义模式）：在命令模式下，用户按 : 键即可进入末行模式下，此时 vi 会在显示窗口的最后一行（通常也是屏幕的最后一行）显示一个:作为末行模式的说明符，等待用户输入命令。多数文件管理命令都是在此模式下执行的（如把编辑缓冲区的内容写到文件中等）。vi 编辑器的 3 种模式的转换如下图所示： VI命令的基本操作一下文本内容的“#”为注释内容，说明功能 进入文件1vi test.py # 打开名为test.py的文件，若不存在则创建并打开该文件 如果只输入 vi，而不带文件名，也可以进入 vi。这时编辑的文件是没有文件名的，所以在退出 vi 时，需要在退出命令后输入文件名，这样才能保证该文件被保存在磁盘中。 修改文件插入文本（i和I） i:将文本插入到光标所在位置前I:I 命令将文本插入当前行的行首 追加文本（a和A） a:将新文本追加到光标当前所在位置之后A:命令将新文本追加到所在行的行尾 空行插入命令(o和O) o：命令将在光标所在行的下面插入一个空行，并将光标置于该行的行首O：命令在光标所在行的上面插入一个空行，并将光标置于该行的行首。 移动光标字符移动 移动命令 意义 h 左移一个光标 j 下移一个光标 k 上移一个光标 l 右移一个光标 按字移动 w 和 W 命令将光标右移至下一个字的字首。区别：-w 所指的字是指英文单词、标点符号和非字母字符；-W 所指的字是指两个空格之间的任何内容； 如果光标起始位置处于字内，则 e 和 E 命令将把光标移到本字字尾；如果光标起始位置处于字尾，则 e 和 E 命令将把光标移动到下一个字的字尾。区别：-e 所指的字是指英文单词、标点符号和非字母字符；-E 所指的字是指两个空格之间的任何内容； 如果光标处于所在字内，则 b 和 B 命令将把光标移至本字字首；如果光标处于所在字字首，则 b 和 B 命令将把光标移到上一个字的字首。区别：-b 命令所指的字是指英文单词、标点符号和非字母字符；-B 命令所指的字是指两个空格之间的任何内容。 按行移动 H：将光标移至当前屏幕的第 1 行，而不是整个文件的第 1 行。若在 H 命令之前加 上数字 n，则将光标移至第 n 行的行首 M：将光标移至屏幕显示文件的中间行的行首。即如果当前屏幕已经充满，则移动到整个屏幕的中间行；否则，移动到显示文本的那些行的中间行。 L：将光标移至屏幕显示文件的最底行的行首。即如果文件内容需要超过一个屏幕显示时，该命令将光标移至屏幕上最底行的行首；否则该命令将光标移至文件最后一行的行首。 G：在全文的范围内移动光标，此时的光标移动范围不再受屏幕的限制。例如，在上例中，在命令模式下输入命令 5G 之后光标将移到第 5 行的行首。 按段落移动光标一个段落被定义为是以一个空白行开始和结束的片段。按段落移动光标的命令有以下两种: {：该命令将光标向前移至上一个段落的开头。 }：该命令将光标向后移至下一个段落的开头。 文本移动文本行移动 >:将指定的正文行向右移动。 >n：n表示光标所在位置后面的文本行数。也可以不写 n，此时默认为 1。&lt;:命令将指定的正文行向左移动。其使用方式与命令相同，但是方向相反。 >&gt;:该命令将光标所在行右移 8 个空格。如果在&gt;&gt;命令之前给出一个数字 n，例如 4，则表示光标当前行及其下面的 3 行（共4行）都右移 8 个空格。 &lt;&lt;:命令将光标所在行左移 8 个空格。其使用与&gt;&gt;命令相同，但是移动方向相反。 文本跨行移动(m命令) imj:表示把第 i 行移至第 j 行的下方。下面实例演示了 m 命令的使用。例：6m2,就是将第6行的内容移动到第2行的下方 替换字符替换 r: 将当前光标所指的字符替换为提供的字符。可以在该命令之前加上数字 n，表示将从当前字符开始的 n 个字符替换为提供的字符。下面实例演示了 r 命令的使用。 R:该命令会让 vi 进入 replace 模式。在此模式下，每个输入的字符都会替换当前光标下的字符，直到输入 \\ 结束该模式。 字符串替换 [range]s/s1/s2/ [option] [range] 表示检索范围，省略时表示当前行；1,10表示从第 1 行到 10 行；%表示整个文件，同1, $；. ,$从当前行到文件尾。 s 为替换命令。 s1 要被替换的串，s2 为替换的串。 option 表示选项：/g表示在全局文件中进行替换;/c表示在每次替换之前需要用户进行确认;省略时仅对每行第一个匹配串进行替换。例如：%s/\\&lt;abc/cde 表示将以 abc 开头的单词替换为以 cde 开头。 辅助操作字符串检索 /String:从光标处开始向后寻找字符串 string。 ?String:从光标处开始向前寻找字符串 string。 文本复制和粘贴 v 命令：在命令模式下进行文本选择。在需要选择的文本的起始处按下 v 键进入块选择模式，然后移动光标到块尾处。这之间的部分被高亮显示，表示被选中. V 命令：在命令模式下按行进行文本选择。在需要选择的文本的第一行按下 V 键，然后移动光标到块的最后一行。这之间的所有行被高亮显示，表示被选中。 yy ：复制光标所在的整行。在 yy 前可加一个数字 n，表示复制当前行及其后 n-1 行的内容。 Y 或 y$ ：两命令功能一样，都是复制从光标所在处开始到行尾的内容。 yw ：复制一个单词。若光标处在某个词的中间，则从光标所在位置开始复制至词尾。同 yy 命令一样，可在 yw 之前加一个数字 n，表示复制 n 个指定的单词。 y) ：复制到下一句幵始的所有字符。 y} ：复制到下一段开始的所有字符。 y\\ （\\ 表示回车）：复制包括当前行在内的两行内容。 p 命令：粘贴命令，粘贴当前缓冲区中的内容 文本删除 删除单个字符 x 命令：删除光标处的字符。若在 x 之前加上一个数字 n，则删除从光标所在位置开始向右的 n 个字符 X 命令：删除光标前面的字符。若在 X 之前加上一个数字 n，则删除从光标前面那个字符开始向左的 n 个字符。 删除多个字符 dd 命令：该命令删除光标所在的整行。在 dd 前可加上一个数字 n，表示删除当前行及其后 n-1 行的内容。 D 命令或 d$ 命令：两个命令功能一样，都是删除从光标所在处开始到行尾的内容。 d0 命令：该命令删除从光标前一个字符开始到行首的内容。 dw 命令：该命令删除一个单词。若光标处在某个词的中间，则从光标所在位置开始删至词尾。同 dd 命令一样，可在 dw 之前加一个数字n，表示删除 n 个指定的单词。 d( 命令：该命令删除到上一句开始的所有字符。 d) 命令：该命令删除到下一句开始的所有字符。 d} 命令：该命令删除到上一段开始的所有字符。 d{ 命令：该命令删除到下一段开始的所有字符。 d\\ 命令：该命令（\\表示回车）删除包括当前行在内的两行字符。 操作撤销 u ：该命令撤销上一次所做的操作。多次使用 u 命令会一步一步依次撤销之前做过的操作（在一次切换到文本输入模式中输入的所有文本算一次操作）。 U ：该命令会一次性撤销自上次移动到当前行以来做过的所有操作，再使用一次 U 命令则撤销之前的 U 命令所做的操作，恢复被撤销的内容。 退出文件 :wq vi将先保存文件，然后退出 vi 返回到 shell。如果当前文件尚未取名，则需要现指定一个文件名。 :x 在末行模式下，若当前编辑文件曾被修改过，则 vi 会保存该文件。否则 vi 直接退出，不保存该文件。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://merlin153.com/tags/Linux/"},{"name":"vi编辑器","slug":"vi编辑器","permalink":"http://merlin153.com/tags/vi编辑器/"}],"author":"墨林"}]}